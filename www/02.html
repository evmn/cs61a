<!--?xml version='1.0' encoding='utf-8'?-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docutils 0.8.1: http://docutils.sourceforge.net/">
<title>Chapter 2: Building Abstractions with Objects</title>
<link rel="stylesheet" href="02_files/lectures.html" type="text/css">

        <script src="02_files/load.js"></script><script src="02_files/jsMath-easy-load.js"></script><script src="02_files/autoload.js"></script>
        <link href="02_files/prettify_002.html" type="text/css" rel="stylesheet">
        <script type="text/javascript" src="02_files/prettify.html"></script></head>
<body onload="prettyPrint();">
<div class="document" id="chapter-2-building-abstractions-with-objects">
<h1 class="title">Chapter 2: Building Abstractions with Objects</h1>
<!-- These notes have been placed in the public domain under the license -->
<!-- Creative Commons Attribution-ShareAlike 3.0 -->
<!-- http://creativecommons.org/licenses/by-sa/3.0/ -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#introduction" id="id2">2.1&nbsp;&nbsp;&nbsp;Introduction</a><ul class="auto-toc">
<li><a class="reference internal" href="#the-object-metaphor" id="id3">2.1.1&nbsp;&nbsp;&nbsp;The Object Metaphor</a></li>
<li><a class="reference internal" href="#native-data-types" id="id4">2.1.2&nbsp;&nbsp;&nbsp;Native Data Types</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-abstraction" id="id5">2.2&nbsp;&nbsp;&nbsp;Data Abstraction</a><ul class="auto-toc">
<li><a class="reference internal" href="#example-arithmetic-on-rational-numbers" id="id6">2.2.1&nbsp;&nbsp;&nbsp;Example: Arithmetic on Rational Numbers</a></li>
<li><a class="reference internal" href="#tuples" id="id7">2.2.2&nbsp;&nbsp;&nbsp;Tuples</a></li>
<li><a class="reference internal" href="#abstraction-barriers" id="id8">2.2.3&nbsp;&nbsp;&nbsp;Abstraction Barriers</a></li>
<li><a class="reference internal" href="#the-properties-of-data" id="id9">2.2.4&nbsp;&nbsp;&nbsp;The Properties of Data</a></li>
</ul>
</li>
<li><a class="reference internal" href="#sequences" id="id10">2.3&nbsp;&nbsp;&nbsp;Sequences</a><ul class="auto-toc">
<li><a class="reference internal" href="#nested-pairs" id="id11">2.3.1&nbsp;&nbsp;&nbsp;Nested Pairs</a></li>
<li><a class="reference internal" href="#recursive-lists" id="id12">2.3.2&nbsp;&nbsp;&nbsp;Recursive Lists</a></li>
<li><a class="reference internal" href="#tuples-ii" id="id13">2.3.3&nbsp;&nbsp;&nbsp;Tuples II</a></li>
<li><a class="reference internal" href="#sequence-iteration" id="id14">2.3.4&nbsp;&nbsp;&nbsp;Sequence Iteration</a></li>
<li><a class="reference internal" href="#sequence-abstraction" id="id15">2.3.5&nbsp;&nbsp;&nbsp;Sequence Abstraction</a></li>
<li><a class="reference internal" href="#strings" id="id16">2.3.6&nbsp;&nbsp;&nbsp;Strings</a></li>
<li><a class="reference internal" href="#conventional-interfaces" id="id17">2.3.7&nbsp;&nbsp;&nbsp;Conventional Interfaces</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mutable-data" id="id18">2.4&nbsp;&nbsp;&nbsp;Mutable Data</a><ul class="auto-toc">
<li><a class="reference internal" href="#local-state" id="id19">2.4.1&nbsp;&nbsp;&nbsp;Local State</a></li>
<li><a class="reference internal" href="#the-benefits-of-non-local-assignment" id="id20">2.4.2&nbsp;&nbsp;&nbsp;The Benefits of Non-Local Assignment</a></li>
<li><a class="reference internal" href="#the-cost-of-non-local-assignment" id="id21">2.4.3&nbsp;&nbsp;&nbsp;The Cost of Non-Local Assignment</a></li>
<li><a class="reference internal" href="#lists" id="id22">2.4.4&nbsp;&nbsp;&nbsp;Lists</a></li>
<li><a class="reference internal" href="#dictionaries" id="id23">2.4.5&nbsp;&nbsp;&nbsp;Dictionaries</a></li>
<li><a class="reference internal" href="#example-propagating-constraints" id="id24">2.4.6&nbsp;&nbsp;&nbsp;Example: Propagating Constraints</a></li>
</ul>
</li>
<li><a class="reference internal" href="#object-oriented-programming" id="id25">2.5&nbsp;&nbsp;&nbsp;Object-Oriented Programming</a><ul class="auto-toc">
<li><a class="reference internal" href="#objects-and-classes" id="id26">2.5.1&nbsp;&nbsp;&nbsp;Objects and Classes</a></li>
<li><a class="reference internal" href="#defining-classes" id="id27">2.5.2&nbsp;&nbsp;&nbsp;Defining Classes</a></li>
<li><a class="reference internal" href="#message-passing-and-dot-expressions" id="id28">2.5.3&nbsp;&nbsp;&nbsp;Message Passing and Dot Expressions</a></li>
<li><a class="reference internal" href="#class-attributes" id="id29">2.5.4&nbsp;&nbsp;&nbsp;Class Attributes</a></li>
<li><a class="reference internal" href="#inheritance" id="id30">2.5.5&nbsp;&nbsp;&nbsp;Inheritance</a></li>
<li><a class="reference internal" href="#using-inheritance" id="id31">2.5.6&nbsp;&nbsp;&nbsp;Using Inheritance</a></li>
<li><a class="reference internal" href="#multiple-inheritance" id="id32">2.5.7&nbsp;&nbsp;&nbsp;Multiple Inheritance</a></li>
<li><a class="reference internal" href="#the-role-of-objects" id="id33">2.5.8&nbsp;&nbsp;&nbsp;The Role of Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#implementing-classes-and-objects" id="id34">2.6&nbsp;&nbsp;&nbsp;Implementing Classes and Objects</a><ul class="auto-toc">
<li><a class="reference internal" href="#instances" id="id35">2.6.1&nbsp;&nbsp;&nbsp;Instances</a></li>
<li><a class="reference internal" href="#classes" id="id36">2.6.2&nbsp;&nbsp;&nbsp;Classes</a></li>
<li><a class="reference internal" href="#using-implemented-objects" id="id37">2.6.3&nbsp;&nbsp;&nbsp;Using Implemented Objects</a></li>
</ul>
</li>
<li><a class="reference internal" href="#generic-operations" id="id38">2.7&nbsp;&nbsp;&nbsp;Generic Operations</a><ul class="auto-toc">
<li><a class="reference internal" href="#string-conversion" id="id39">2.7.1&nbsp;&nbsp;&nbsp;String Conversion</a></li>
<li><a class="reference internal" href="#multiple-representations" id="id40">2.7.2&nbsp;&nbsp;&nbsp;Multiple Representations</a></li>
<li><a class="reference internal" href="#generic-functions" id="id41">2.7.3&nbsp;&nbsp;&nbsp;Generic Functions</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="introduction">
<h2><a class="toc-backref" href="#id2">2.1&nbsp;&nbsp;&nbsp;Introduction</a></h2>
<p>We concentrated in Chapter 1 on computational processes and on the role of
functions in program design. We saw how to use primitive data (numbers) and
primitive operations (arithmetic operations), how to form compound functions
through composition and control, and how to create functional abstractions by
giving names to processes. We also saw that higher-order functions enhance the
power of our language by enabling us to manipulate, and thereby to reason, in
terms of general methods of computation. This is much of the essence of
programming.</p>
<p>This chapter focuses on data.  Data allow us to represent and manipulate
information about the world using the computational tools we have acquired so
far.  Programs without data structures may suffice for exploring mathematical
properties. But real-world phenomena, such as documents, relationships, cities,
and weather patterns, all have complex structure that is best represented using
<em>compound data types</em>.  With structured data, programs can simulate and reason
about virtually any domain of human knowledge and experience.  Thanks to the
explosive growth of the Internet, a vast amount of structured information about
the world is freely available to us all online.</p>
<div class="section" id="the-object-metaphor">
<h3><a class="toc-backref" href="#id3">2.1.1&nbsp;&nbsp;&nbsp;The Object Metaphor</a></h3>
<p>In the beginning of this course, we distinguished between functions and data:
functions performed operations and data were operated upon.  When we included
function values among our data, we acknowledged that data too can have behavior.
Functions could be operated upon like data, but could also be called to perform
computation.</p>
<p>In this course, <em>objects</em> will serve as our central programming metaphor for
data values that also have behavior.  Objects represent information, but also
<em>behave</em> like the abstract concepts that they represent.  The logic of how an
object interacts with other objects is bundled along with the information that
encodes the object's value.  When an object is printed, it knows how to spell
itself out in letters and numbers.  If an object is composed of parts, it knows
how to reveal those parts on demand.  Objects are both information and
processes, bundled together to represent the properties, interactions, and
behaviors of complex things.</p>
<p>The object metaphor is implemented in Python through specialized object syntax
and associated terminology, which we can introduce by example.  A date is a kind
of simple object.</p>
<pre class="doctest-block">&gt;&gt;&gt; from datetime import date
</pre>
<p>The name <tt class="docutils literal">date</tt> is bound to a <em>class</em>. A class represents a kind of object.
Individual dates are called <em>instances</em> of that class, and they can be
<em>constructed</em> by calling the class as a function on arguments that characterize
the instance.</p>
<pre class="doctest-block">&gt;&gt;&gt; today = date(2011, 9, 12)
</pre>
<p>While <tt class="docutils literal">today</tt> was constructed from primitive numbers, it behaves like a date.
For instance, subtracting it from another date will give a time difference,
which we can display as a line of text by calling <tt class="docutils literal">str</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; str(date(2011, 12, 2) - today)
'81 days, 0:00:00'
</pre>
<p>Objects have <em>attributes</em>, which are named values that are part of the object.
In Python, we use dot notation to designated an attribute of an object.</p>
<blockquote>
&lt;expression&gt; . &lt;name&gt;</blockquote>
<p>Above, the <tt class="docutils literal">&lt;expression&gt;</tt> evaluates to an object, and <tt class="docutils literal">&lt;name&gt;</tt> is the name
of an attribute for that object.</p>
<p>Unlike the names that we have considered so far, these attribute names are not
available in the general environment.  Instead, attribute names are particular
to the object instance preceding the dot.</p>
<pre class="doctest-block">&gt;&gt;&gt; today.year
2011
</pre>
<p>Objects also have <em>methods</em>, which are function-valued attributes.
Metaphorically, the object "knows" how to carry out those methods.  Methods
compute their results from both their arguments and their object.  For example,
The <tt class="docutils literal">strftime</tt> method of <tt class="docutils literal">today</tt> takes a single argument that specifies how
to display a date (e.g., <tt class="docutils literal">%A</tt> means that the day of the week should be spelled
out in full).</p>
<pre class="doctest-block">&gt;&gt;&gt; today.strftime('%A, %B %d')
'Monday, September 12'
</pre>
<p>Computing the return value  of <tt class="docutils literal">strftime</tt> requires two inputs: the string that
describes the format of the output and the date information bundled into
<tt class="docutils literal">today</tt>.  Date-specific logic is applied within this method to yield this
result.  We never stated that the 12th of September, 2011, was a Monday, but
knowing one's weekday is part of what it means to be a date.  By bundling
behavior and information together, this Python object offers us a convincing,
self-contained abstraction of a date.</p>
<p>Dot notation provides another form of combined expression in Python. Dot
notation also has a well-defined evaluation procedure.  However, developing a
precise account of how dot notation is evaluated will have to wait until we
introduce the full paradigm of object-oriented programming over the next several
sections.</p>
<p>Even though we haven't described precisely how objects work yet, it is time to
start thinking about data as objects now, because in Python every value is an
object.</p>
</div>
<div class="section" id="native-data-types">
<h3><a class="toc-backref" href="#id4">2.1.2&nbsp;&nbsp;&nbsp;Native Data Types</a></h3>
<p>Every object in Python has a <em>type</em>. The <tt class="docutils literal">type</tt> function allows us to inspect
the type of an object.</p>
<pre class="doctest-block">&gt;&gt;&gt; type(today)
&lt;class 'datetime.date'&gt;
</pre>
<p>So far, the only kinds of objects we have studied are numbers, functions,
Booleans, and now dates.  We also briefly encountered sets and strings, but we
will need to study those in more depth.  There are many other kinds of objects
--- sounds, images, locations, data connections, etc. --- most of which can be
defined by the means of combination and abstraction that we develop in this
chapter.  Python has only a handful of primitive or <em>native</em> data types built
into the language.</p>
<p>Native data types have the following properties:</p>
<ol class="arabic simple">
<li>There are primitive expressions that evaluate to objects of these types,
called <em>literals</em>.</li>
<li>There are built-in functions, operators, and methods to manipulate these
objects.</li>
</ol>
<p>As we have seen, numbers are native; numeric literals evaluate to numbers, and
mathematical operators manipulate number objects.</p>
<pre class="doctest-block">&gt;&gt;&gt; 12 + 3000000000000000000000000
3000000000000000000000012
</pre>
<p>In fact, Python includes three native numeric types: integers (<tt class="docutils literal">int</tt>),
real numbers (<tt class="docutils literal">float</tt>), and complex numbers (<tt class="docutils literal">complex</tt>).</p>
<pre class="doctest-block">&gt;&gt;&gt; type(2)
&lt;class 'int'&gt;
&gt;&gt;&gt; type(1.5)
&lt;class 'float'&gt;
&gt;&gt;&gt; type(1+1j)
&lt;class 'complex'&gt;
</pre>
<p>The name <tt class="docutils literal">float</tt> comes from the way in which real numbers are represented in
Python: a "floating point" representation.  While the details of how numbers are
represented is not a topic for this course, some high-level differences between
<tt class="docutils literal">int</tt> and <tt class="docutils literal">float</tt> objects are important to know.  In particular, <tt class="docutils literal">int</tt>
objects can only represent integers, but they represent them exactly, without
any approximation.  On the other hand, <tt class="docutils literal">float</tt> objects can represent a wide
range of fractional numbers, but not all rational numbers are representable.
Nonetheless, float objects are often used to represent real and rational numbers
approximately, up to some number of significant figures.</p>
<p><strong>Further reading.</strong> The following sections introduce more of Python's native
data types, focusing on the role they play in creating useful data abstractions.
A chapter on <a class="reference external" href="http://diveintopython3.ep.io/native-datatypes.html">native data types</a> in Dive Into Python 3 gives
a pragmatic overview of all Python's native data types and how to use them
effectively, including numerous usage examples and practical tips.  You needn't
read that chapter now, but consider it a valuable reference.</p>
</div>
</div>
<div class="section" id="data-abstraction">
<h2><a class="toc-backref" href="#id5">2.2&nbsp;&nbsp;&nbsp;Data Abstraction</a></h2>
<p>As we consider the wide set of things in the world that we would like to
represent in our programs, we find that most of them have compound structure.  A
date has a year, a month, and a day; a geographic position has a latitude and a
longitude.  To represent positions, we  would like our programming language to
have the capacity to "glue together" a latitude and longitude to form a pair ---
a <em>compound data</em> value --- that our programs could manipulate in a way that
would be consistent with the fact that we regard a position as a single
conceptual unit, which has two parts.</p>
<p>The use of compound data also enables us to increase the modularity of our
programs. If we can manipulate geographic positions directly as objects
in their own right, then we can separate the part of our program that deals with
values per se from the details of how those values may be represented. The
general technique of isolating the parts of a program that deal with how data
are represented from the parts of a program that deal with how those
data are manipulated is a powerful design methodology called <em>data abstraction</em>.
Data abstraction makes programs much easier to design, maintain, and modify.</p>
<p>Data abstraction is similar in character to functional abstraction.  When we
create a functional abstraction, the details of how a function is implemented
can be suppressed, and the particular function itself can be replaced by any
other function with the same overall behavior.  In other words, we can make an
abstraction that separates the way the function is used from the details of how
the function is implemented.  Analogously, data abstraction is a methodology
that enables us to isolate how a compound data object is used from the details
of how it is constructed.</p>
<p>The basic idea of data abstraction is to structure programs so that they operate
on abstract data. That is, our programs should use data in such a way as to make
as few assumptions about the data as possible. At the same time, a concrete data
representation is defined, independently of the programs that use the data. The
interface between these two parts of our system will be a set of functions,
called selectors and constructors, that implement the abstract data in terms of
the concrete representation. To illustrate this technique, we will consider how
to design a set of functions for manipulating rational numbers.</p>
<p>As you read the next few sections, keep in mind that most Python code written
today uses very high-level abstract data types that are built into the language,
like classes, dictionaries, and lists.  Since we're building up an understanding
of how these abstractions work, we can't use them yet ourselves.  As a
consequence, we will write some code that isn't Pythonic --- it's not necessarily
the typical way to implement our ideas in the language.  What we write is
instructive, however, because it demonstrates how these abstractions can be
constructed!  Remember that computer science isn't just about learning to use
programming languages, but also learning how they work.</p>
<div class="section" id="example-arithmetic-on-rational-numbers">
<h3><a class="toc-backref" href="#id6">2.2.1&nbsp;&nbsp;&nbsp;Example: Arithmetic on Rational Numbers</a></h3>
<p>Recall that a rational number is a ratio of integers, and rational numbers
constitute an important sub-class of real numbers.  A rational number like
<tt class="docutils literal">1/3</tt> or <tt class="docutils literal">17/29</tt> is typically written as:</p>
<pre class="literal-block">&lt;numerator&gt;/&lt;denominator&gt;
</pre>
<p>where both the <tt class="docutils literal">&lt;numerator&gt;</tt> and <tt class="docutils literal">&lt;denominator&gt;</tt> are placeholders for
integer values.  Both parts are needed to exactly characterize the value of the
rational number.</p>
<p>Rational numbers are important in computer science because they, like integers,
can be represented exactly.  Irrational numbers (like <tt class="docutils literal">pi</tt> or <tt class="docutils literal">e</tt> or
<tt class="docutils literal">sqrt(2)</tt>) are instead approximated using a finite binary expansion.  Thus,
working with rational numbers should, in principle, allow us to avoid
approximation errors in our arithmetic.</p>
<p>However, as soon as we actually divide the numerator by the denominator, we can
be left with a truncated decimal approximation (a <tt class="docutils literal">float</tt>).</p>
<pre class="doctest-block">&gt;&gt;&gt; 1/3
0.3333333333333333
</pre>
<p>and the problems with this approximation appear when we start to conduct tests:</p>
<pre class="doctest-block">&gt;&gt;&gt; 1/3 == 0.333333333333333300000  # Beware of approximations
True
</pre>
<p>How computers approximate real numbers with finite-length decimal expansions is
a topic for another class. The important idea here is that by representing
rational numbers as ratios of integers, we avoid the approximation problem
entirely. Hence, we would like to keep the numerator and denominator separate
for the sake of precision, but treat them as a single unit.</p>
<p>We know from using functional abstractions that we can start programming
productively before we have an implementation of some parts of our program.  Let
us begin by assuming that we already have a way of constructing a rational
number from a numerator and a denominator. We also assume that, given a rational
number, we have a way of extracting (or selecting) its numerator and its
denominator. Let us further assume that the constructor and selectors are
available as the following three functions:</p>
<ul class="simple">
<li><tt class="docutils literal">make_rat(n, d)</tt> returns the rational number with numerator <tt class="docutils literal">n</tt> and
denominator <tt class="docutils literal">d</tt>.</li>
<li><tt class="docutils literal">numer(x)</tt> returns the numerator of the rational number <tt class="docutils literal">x</tt>.</li>
<li><tt class="docutils literal">denom(x)</tt> returns the denominator of the rational number <tt class="docutils literal">x</tt>.</li>
</ul>
<p>We are using here a powerful strategy of synthesis: <em>wishful thinking</em>. We
haven't yet said how a rational number is represented, or how the functions
<tt class="docutils literal">numer</tt>, <tt class="docutils literal">denom</tt>, and <tt class="docutils literal">make_rat</tt> should be implemented. Even so, if we did
have these three functions, we could then add, multiply, and test equality of
rational numbers by calling them:</p>
<pre class="doctest-block">&gt;&gt;&gt; def add_rat(x, y):
        nx, dx = numer(x), denom(x)
        ny, dy = numer(y), denom(y)
        return make_rat(nx * dy + ny * dx, dx * dy)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def mul_rat(x, y):
        return make_rat(numer(x) * numer(y), denom(x) * denom(y))
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def eq_rat(x, y):
        return numer(x) * denom(y) == numer(y) * denom(x)
</pre>
<p>Now we have the operations on rational numbers defined in terms of the selector
functions <tt class="docutils literal">numer</tt> and <tt class="docutils literal">denom</tt>, and the constructor function <tt class="docutils literal">make_rat</tt>,
but we haven't yet defined these functions. What we need is some way to glue
together a numerator and a denominator into a unit.</p>
</div>
<div class="section" id="tuples">
<h3><a class="toc-backref" href="#id7">2.2.2&nbsp;&nbsp;&nbsp;Tuples</a></h3>
<p>To enable us to implement the concrete level of our data abstraction, Python
provides a compound structure called a <tt class="docutils literal">tuple</tt>, which can be constructed by
separating values by commas.  Although not strictly required, parentheses almost
always surround tuples.</p>
<pre class="doctest-block">&gt;&gt;&gt; (1, 2)
(1, 2)
</pre>
<p>The elements of a tuple can be unpacked in two ways.  The first way is via our
familiar method of multiple assignment.</p>
<pre class="doctest-block">&gt;&gt;&gt; pair = (1, 2)
&gt;&gt;&gt; pair
(1, 2)
&gt;&gt;&gt; x, y = pair
&gt;&gt;&gt; x
1
&gt;&gt;&gt; y
2
</pre>
<p>In fact, multiple assignment has been creating and unpacking tuples all along.</p>
<p>A second method for accessing the elements in a tuple is by the indexing
operator, written as square brackets.</p>
<pre class="doctest-block">&gt;&gt;&gt; pair[0]
1
&gt;&gt;&gt; pair[1]
2
</pre>
<p>Tuples in Python (and sequences in most other programming languages) are
0-indexed, meaning that the index <tt class="docutils literal">0</tt> picks out the first element, index <tt class="docutils literal">1</tt>
picks out the second, and so on.  One intuition that underlies this indexing
convention is that the index represents how far an element is offset from the
beginning of the tuple.</p>
<p>The equivalent function for the element selection operator is called
<tt class="docutils literal">getitem</tt>, and it also uses 0-indexed positions to select elements from a
tuple.</p>
<pre class="doctest-block">&gt;&gt;&gt; from operator import getitem
&gt;&gt;&gt; getitem(pair, 0)
1
</pre>
<p>Tuples are native types, which means that there are built-in Python operators to
manipulate them.  We'll return to the full properties of tuples shortly.  At
present, we are only interested in how tuples can serve as the glue that
implements abstract data types.</p>
<p><strong>Representing Rational Numbers.</strong> Tuples offer a natural way to implement
rational numbers as a pair of two integers: a numerator and a denominator. We
can implement our constructor and selector functions for rational numbers by
manipulating 2-element tuples.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_rat(n, d):
        return (n, d)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def numer(x):
        return getitem(x, 0)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def denom(x):
        return getitem(x, 1)
</pre>
<p>A function for printing rational numbers completes our implementation of this
abstract data type.</p>
<pre class="doctest-block">&gt;&gt;&gt; def str_rat(x):
        """Return a string 'n/d' for numerator n and denominator d."""
        return '{0}/{1}'.format(numer(x), denom(x))
</pre>
<p>Together with the arithmetic operations we defined earlier, we can manipulate
rational numbers with the functions we have defined.</p>
<pre class="doctest-block">&gt;&gt;&gt; half = make_rat(1, 2)
&gt;&gt;&gt; str_rat(half)
'1/2'
&gt;&gt;&gt; third = make_rat(1, 3)
&gt;&gt;&gt; str_rat(mul_rat(half, third))
'1/6'
&gt;&gt;&gt; str_rat(add_rat(third, third))
'6/9'
</pre>
<p>As the final example shows, our rational-number implementation does not reduce
rational numbers to lowest terms. We can remedy this by changing <tt class="docutils literal">make_rat</tt>.
If we have a function for computing the greatest common denominator of two
integers, we can use it to reduce the numerator and the denominator to lowest
terms before constructing the pair.  As with many useful tools, such a function
already exists in the Python Library.</p>
<pre class="doctest-block">&gt;&gt;&gt; from fractions import gcd
&gt;&gt;&gt; def make_rat(n, d):
        g = gcd(n, d)
        return (n//g, d//g)
</pre>
<p>The double slash operator, <tt class="docutils literal">//</tt>, expresses integer division, which rounds down
the fractional part of the result of division.  Since we know that <tt class="docutils literal">g</tt> divides
both <tt class="docutils literal">n</tt> and <tt class="docutils literal">d</tt> evenly, integer division is exact in this case.  Now we have</p>
<pre class="doctest-block">&gt;&gt;&gt; str_rat(add_rat(third, third))
'2/3'
</pre>
<p>as desired. This modification was accomplished by changing the constructor
without changing any of the functions that implement the actual arithmetic
operations.</p>
<p><strong>Further reading.</strong> The <tt class="docutils literal">str_rat</tt> implementation above uses <em>format strings</em>,
which contain placeholders for values.  The details of how to use format strings
and the <tt class="docutils literal">format</tt> method appear in the <a class="reference external" href="http://diveintopython3.ep.io/strings.html#formatting-strings">formatting strings</a> section of Dive
Into Python 3.</p>
</div>
<div class="section" id="abstraction-barriers">
<h3><a class="toc-backref" href="#id8">2.2.3&nbsp;&nbsp;&nbsp;Abstraction Barriers</a></h3>
<p>Before continuing with more examples of compound data and data abstraction, let
us consider some of the issues raised by the rational number example. We defined
operations in terms of a constructor <tt class="docutils literal">make_rat</tt> and selectors <tt class="docutils literal">numer</tt> and
<tt class="docutils literal">denom</tt>. In general, the underlying idea of data abstraction is to identify
for each type of value a basic set of operations in terms of which all
manipulations of values of that type will be expressed, and then to use
only those operations in manipulating the data.</p>
<p>We can envision the structure of the rational number system as a series of
layers.</p>
<div class="figure">
<img alt="img/barriers.png" src="02_files/barriers.png">
</div>
<p>The horizontal lines represent abstraction barriers that isolate different
levels of the system. At each level, the barrier separates the functions (above)
that use the data abstraction from the functions (below) that implement the data
abstraction. Programs that use rational numbers manipulate them solely in terms
of the their arithmetic functions: <tt class="docutils literal">add_rat</tt>, <tt class="docutils literal">mul_rat</tt>, and
<tt class="docutils literal">eq_rat</tt>. These, in turn, are implemented solely in terms of the
constructor and selectors <tt class="docutils literal">make_rat</tt>, <tt class="docutils literal">numer</tt>, and <tt class="docutils literal">denom</tt>, which
themselves are implemented in terms of tuples. The details of how tuples are
implemented are irrelevant to the rest of the layers as long as tuples enable
the implementation of the selectors and constructor.</p>
<p>At each layer, the functions within the box enforce the abstraction boundary
because they are the only functions that depend upon both the representation
above them (by their use) and the implementation below them (by their
definitions). In this way, abstraction barriers are expressed as sets of
functions.</p>
<p>Abstraction barriers provide many advantages. One advantage is that they makes
programs much easier to maintain and to modify. The fewer functions that depend
on a particular representation, the fewer changes are required when one wants to
change that representation.</p>
</div>
<div class="section" id="the-properties-of-data">
<h3><a class="toc-backref" href="#id9">2.2.4&nbsp;&nbsp;&nbsp;The Properties of Data</a></h3>
<p>We began the rational-number implementation by implementing arithmetic
operations in terms of three unspecified functions: <tt class="docutils literal">make_rat</tt>, <tt class="docutils literal">numer</tt>, and
<tt class="docutils literal">denom</tt>. At that point, we could think of the operations as being defined in
terms of data objects --- numerators, denominators, and rational numbers --- whose
behavior was specified by the latter three functions.</p>
<p>But what exactly is meant by data? It is not enough to say "whatever is
implemented by the given selectors and constructors." We need to guarantee that
these functions together specify the right behavior.  That is, if we construct a
rational number <tt class="docutils literal">x</tt> from integers <tt class="docutils literal">n</tt> and <tt class="docutils literal">d</tt>, then it should be the case
that <tt class="docutils literal"><span class="pre">numer(x)/denom(x)</span></tt> is equal to <tt class="docutils literal">n/d</tt>.</p>
<p>In general, we can think of an abstract data type as defined by some collection
of selectors and constructors, together with some behavior conditions.  As long
as the behavior conditions are met (such as the division property above), these
functions constitute a valid representation of the data type.</p>
<p>This point of view can be applied to other data types as well, such as the
two-element tuple that we used in order to implement rational numbers. We never
actually said much about what a tuple was, only that the language supplied
operators to create and manipulate tuples. We can now describe the behavior
conditions of two-element tuples, also called pairs, that are relevant to the
problem of representing rational numbers.</p>
<p>In order to implement rational numbers, we needed a form of glue for two
integers, which had the following behavior:</p>
<ul class="simple">
<li>If a pair <tt class="docutils literal">p</tt> was constructed from values <tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt>, then
<tt class="docutils literal">getitem_pair(p, 0)</tt> returns <tt class="docutils literal">x</tt>, and <tt class="docutils literal">getitem_pair(p, 1)</tt> returns
<tt class="docutils literal">y</tt>.</li>
</ul>
<p>We can implement functions <tt class="docutils literal">make_pair</tt> and <tt class="docutils literal">getitem_pair</tt> that fulfill this
description just as well as a tuple.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_pair(x, y):
        """Return a function that behaves like a pair."""
        def dispatch(m):
            if m == 0:
                return x
            elif m == 1:
                return y
        return dispatch
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def getitem_pair(p, i):
        """Return the element at index i of pair p."""
        return p(i)
</pre>
<p>With this implementation, we can create and manipulate pairs.</p>
<pre class="doctest-block">&gt;&gt;&gt; p = make_pair(1, 2)
&gt;&gt;&gt; getitem_pair(p, 0)
1
&gt;&gt;&gt; getitem_pair(p, 1)
2
</pre>
<p>This use of functions corresponds to nothing like our intuitive notion of what
data should be. Nevertheless, these functions suffice to represent compound
data in our programs.</p>
<p>The subtle point to notice is that the value returned by <tt class="docutils literal">make_pair</tt> is a
function called <tt class="docutils literal">dispatch</tt>, which takes an argument <tt class="docutils literal">m</tt> and returns either
<tt class="docutils literal">x</tt> or <tt class="docutils literal">y</tt>. Then, <tt class="docutils literal">getitem_pair</tt> calls this function to retrieve the
appropriate value.  We will return to the topic of dispatch functions several
times throughout this chapter.</p>
<p>The point of exhibiting the functional representation of a pair is not that
Python actually works this way (tuples are implemented more directly, for
efficiency reasons) but that it could work this way. The functional
representation, although obscure, is a perfectly adequate way to represent
pairs, since it fulfills the only conditions that pairs need to fulfill. This
example also demonstrates that the ability to manipulate functions as values
automatically provides us the ability to represent compound data.</p>
</div>
</div>
<div class="section" id="sequences">
<h2><a class="toc-backref" href="#id10">2.3&nbsp;&nbsp;&nbsp;Sequences</a></h2>
<p>A sequence is an ordered collection of data values.  Unlike a pair, which has
exactly two elements, a sequence can have an arbitrary (but finite) number of
ordered elements.</p>
<p>The sequence is a powerful, fundamental abstraction in computer science.  For
example, if we have sequences, we can list every student at Berkeley, or every
university in the world, or every student in every university.  We can list
every class ever taken, every assignment ever completed, every grade ever
received. The sequence abstraction enables the thousands of data-driven programs
that impact our lives every day.</p>
<p>A sequence is not a particular abstract data type, but instead a collection of
behaviors that different types share.  That is, there are many kinds of
sequences, but they all share certain properties.  In particular,</p>
<p><strong>Length.</strong> A sequence has a finite length.</p>
<p><strong>Element selection.</strong> A sequence has an element corresponding to any
non-negative integer index less than its length, starting at 0 for the first
element.</p>
<p>Unlike an abstract data type, we have not stated how to construct a sequence.
The sequence abstraction is a collection of behaviors that does not fully
specify a type (i.e., with constructors and selectors), but may be shared among
several types. Sequences provide a layer of abstraction that may hide the
details of exactly which sequence type is being manipulated by a particular
program.</p>
<p>In this section, we develop a particular abstract data type that can implement
the sequence abstraction.  We then introduce built-in Python types that also
implement the same abstraction.</p>
<div class="section" id="nested-pairs">
<h3><a class="toc-backref" href="#id11">2.3.1&nbsp;&nbsp;&nbsp;Nested Pairs</a></h3>
<p>For rational numbers, we paired together two integer objects using a two-element
tuple, then showed that we could implement pairs just as well using functions.
In that case, the elements of each pair we constructed were integers.  However, like
expressions, tuples can nest. Either element of a pair can itself be a pair, a
property that holds true for either method of implementing a pair that we have
seen: as a tuple or as a dispatch function.</p>
<p>A standard way to visualize a pair --- in this case, the pair <tt class="docutils literal">(1,2)</tt> --- is
called <em>box-and-pointer</em> notation. Each value, compound or primitive, is
depicted as a pointer to a box.  The box for a primitive value contains a
representation of that value. For example, the box for a number contains a
numeral. The box for a pair is actually a double box: the left part contains (an
arrow to) the first element of the pair and the right part contains the second.</p>
<div class="figure">
<img alt="img/pair.png" src="02_files/pair.png">
</div>
<p>This Python expression for a nested tuple,</p>
<pre class="doctest-block">&gt;&gt;&gt; ((1, 2), (3, 4))
((1, 2), (3, 4))
</pre>
<p>would have the following structure.</p>
<div class="figure">
<img alt="img/nested_pairs.png" src="02_files/nested_pairs.png">
</div>
<p>Our ability to use tuples as the elements of other tuples provides a new means
of combination in our programming language.  We call the ability for tuples to
nest in this way a <em>closure property</em> of the tuple data type.  In general, a
method for combining data values satisfies the closure property if the result of
combination can itself be combined using the same method.  Closure is the key to
power in any means of combination because it permits us to create hierarchical
structures --- structures made up of parts, which themselves are made up of
parts, and so on.  We will explore a range of hierarchical structures in Chapter
3.  For now, we consider a particularly important structure.</p>
</div>
<div class="section" id="recursive-lists">
<h3><a class="toc-backref" href="#id12">2.3.2&nbsp;&nbsp;&nbsp;Recursive Lists</a></h3>
<p>We can use nested pairs to form lists of elements of arbitrary length, which
will allow us to implement the sequence abstraction.  The figure below
illustrates the structure of the recursive representation of a four-element
list: <tt class="docutils literal">1</tt>, <tt class="docutils literal">2</tt>, <tt class="docutils literal">3</tt>, <tt class="docutils literal">4</tt>.</p>
<div class="figure">
<img alt="img/sequence.png" src="02_files/sequence.png">
</div>
<p>The list is represented by a chain of pairs.  The first element of each pair
is an element in the list, while the second is a pair that represents the rest
of the list.  The second element of the final pair is <tt class="docutils literal">None</tt>, which indicates
that the list has ended.  We can construct this structure using a nested tuple
literal:</p>
<pre class="doctest-block">&gt;&gt;&gt; (1, (2, (3, (4, None))))
(1, (2, (3, (4, None))))
</pre>
<p>This nested structure corresponds to a very useful way of thinking about
sequences in general, which we have seen before in the execution rules of the
Python interpreter. A non-empty sequence can be decomposed into:</p>
<ul class="simple">
<li>its first element, and</li>
<li>the rest of the sequence.</li>
</ul>
<p>The rest of a sequence is itself a (possibly empty) sequence.  We call this view
of sequences recursive, because sequences contain other sequences as their
second component.</p>
<p>Since our list representation is recursive, we will call it an <tt class="docutils literal">rlist</tt> in our
implementation, so as not to confuse it with the built-in <tt class="docutils literal">list</tt> type in
Python that we will introduce later in this chapter. A recursive list can be
constructed from a first element and the rest of the list. The value <tt class="docutils literal">None</tt>
represents an empty recursive list.</p>
<pre class="doctest-block">&gt;&gt;&gt; empty_rlist = None
&gt;&gt;&gt; def make_rlist(first, rest):
        """Make a recursive list from its first element and the rest."""
        return (first, rest)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def first(s):
        """Return the first element of a recursive list s."""
        return s[0]
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def rest(s):
        """Return the rest of the elements of a recursive list s."""
        return s[1]
</pre>
<p>These two selectors, one constructor, and one constant together implement the
recursive list abstract data type.  The single behavior condition for a
recursive list is that, like a pair, its constructor and selectors are inverse
functions.</p>
<ul class="simple">
<li>If a recursive list <tt class="docutils literal">s</tt> was constructed from element <tt class="docutils literal">f</tt> and list <tt class="docutils literal">r</tt>,
then <tt class="docutils literal">first(s)</tt> returns <tt class="docutils literal">f</tt>, and <tt class="docutils literal">rest(s)</tt> returns <tt class="docutils literal">r</tt>.</li>
</ul>
<p>We can use the constructor and selectors to manipulate recursive lists.</p>
<pre class="doctest-block">&gt;&gt;&gt; counts = make_rlist(1, make_rlist(2, make_rlist(3, make_rlist(4, empty_rlist))))
&gt;&gt;&gt; first(counts)
1
&gt;&gt;&gt; rest(counts)
(2, (3, (4, None)))
</pre>
<p>Recall that we were able to represent pairs using functions, and therefore we
can represent recursive lists using functions as well.</p>
<p>The recursive list can store a sequence of values in order, but it does not yet
implement the sequence abstraction.  Using the abstract data type we have
defined, we can implement the two behaviors that characterize a sequence: length
and element selection.</p>
<pre class="doctest-block">&gt;&gt;&gt; def len_rlist(s):
        """Return the length of recursive list s."""
        length = 0
        while s != empty_rlist:
            s, length = rest(s), length + 1
        return length
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def getitem_rlist(s, i):
        """Return the element at index i of recursive list s."""
        while i &gt; 0:
            s, i = rest(s), i - 1
        return first(s)
</pre>
<p>Now, we can manipulate a recursive list as a sequence:</p>
<pre class="doctest-block">&gt;&gt;&gt; len_rlist(counts)
4
&gt;&gt;&gt; getitem_rlist(counts, 1)  # The second item has index 1
2
</pre>
<p>Both of these implementations are iterative.  They peel away each layer of
nested pair until the end of the list (in <tt class="docutils literal">len_rlist</tt>) or the desired element
(in <tt class="docutils literal">getitem_rlist</tt>) is reached.</p>
<p>The series of environment diagrams below illustrate the iterative process by
which <tt class="docutils literal">getitem_rlist</tt> finds the element <tt class="docutils literal">2</tt> at index <tt class="docutils literal">1</tt> in the recursive
list.  First, the function <tt class="docutils literal">getitem_rlist</tt> is called, creating a local frame.</p>
<div class="figure">
<img alt="img/getitem_rlist_0.png" src="02_files/getitem_rlist_0.png">
</div>
<p>The expression in the <tt class="docutils literal">while</tt> header evaluates to true, which causes the
assignment statement in the <tt class="docutils literal">while</tt> suite to be executed.</p>
<div class="figure">
<img alt="img/getitem_rlist_1.png" src="02_files/getitem_rlist_1.png">
</div>
<p>In this case, the local name <tt class="docutils literal">s</tt> now refers to the sub-list that begins
with the second element of the original list.  Evaluating the <tt class="docutils literal">while</tt>
header expression now yields a false value, and so Python evaluates the
expression in the return statement on the final line of <tt class="docutils literal">getitem_rlist</tt>.</p>
<div class="figure">
<img alt="img/getitem_rlist_2.png" src="02_files/getitem_rlist_2.png">
</div>
<p>This final environment diagram shows the local frame for the call to <tt class="docutils literal">first</tt>,
which contains the name <tt class="docutils literal">s</tt> bound to that same sub-list.  The <tt class="docutils literal">first</tt>
function selects the value <tt class="docutils literal">2</tt> and returns it, completing the call to
<tt class="docutils literal">getitem_rlist</tt>.</p>
<p>This example demonstrates a common pattern of computation with recursive lists,
where each step in an iteration operates on an increasingly shorter suffix of
the original list. This incremental processing to find the length and elements
of a recursive list does take some time to compute.  (In Chapter 3, we will
learn to characterize the computation time of iterative functions like
these.)  Python's built-in sequence types are implemented in a different way
that does not have a large computational cost for computing the length of a
sequence or retrieving its elements.</p>
<p>The way in which we construct recursive lists is rather verbose. Fortunately,
Python provides a variety of built-in sequence types that provide both the
versatility of the sequence abstraction, as well as convenient notation.</p>
</div>
<div class="section" id="tuples-ii">
<h3><a class="toc-backref" href="#id13">2.3.3&nbsp;&nbsp;&nbsp;Tuples II</a></h3>
<p>In fact, the <tt class="docutils literal">tuple</tt> type that we introduced to form primitive pairs is itself
a full sequence type.  Tuples provide substantially more functionality than the
pair abstract data type that we implemented functionally.</p>
<p>Tuples can have arbitrary length, and they exhibit the two principal behaviors of
the sequence abstraction: length and element selection. Below, <tt class="docutils literal">digits</tt> is a
tuple with four elements.</p>
<pre class="doctest-block">&gt;&gt;&gt; digits = (1, 8, 2, 8)
&gt;&gt;&gt; len(digits)
4
&gt;&gt;&gt; digits[3]
8
</pre>
<p>Additionally, tuples can be added together and multiplied by integers.  For
tuples, addition and multiplication do not add or multiply elements, but instead
combine and replicate the tuples themselves. That is, the <tt class="docutils literal">add</tt> function in
the <tt class="docutils literal">operator</tt> module (and the <tt class="docutils literal">+</tt> operator) returns a new tuple that is the
conjunction of the added arguments.  The <tt class="docutils literal">mul</tt> function in <tt class="docutils literal">operator</tt> (and
the <tt class="docutils literal">*</tt> operator) can take an integer <tt class="docutils literal">k</tt> and a tuple and return a new tuple
that consists of <tt class="docutils literal">k</tt> copies of the tuple argument.</p>
<pre class="doctest-block">&gt;&gt;&gt; (2, 7) + digits * 2
(2, 7, 1, 8, 2, 8, 1, 8, 2, 8)
</pre>
<p><strong>Mapping.</strong> A powerful method of transforming one tuple into another is by
applying a function to each element and collecting the results.  This general
form of computation is called <em>mapping</em> a function over a sequence, and
corresponds to the built-in function <tt class="docutils literal">map</tt>.  The result of <tt class="docutils literal">map</tt> is an
object that is not itself a sequence, but can be converted into a sequence by
calling <tt class="docutils literal">tuple</tt>, the constructor function for tuples.</p>
<pre class="doctest-block">&gt;&gt;&gt; alternates = (-1, 2, -3, 4, -5)
&gt;&gt;&gt; tuple(map(abs, alternates))
(1, 2, 3, 4, 5)
</pre>
<p>The <tt class="docutils literal">map</tt> function is important because it relies on the sequence abstraction:
we do not need to be concerned about the structure of the underlying tuple; only
that we can access each one of its elements individually in order to pass it as
an argument to the mapped function (<tt class="docutils literal">abs</tt>, in this case).</p>
</div>
<div class="section" id="sequence-iteration">
<h3><a class="toc-backref" href="#id14">2.3.4&nbsp;&nbsp;&nbsp;Sequence Iteration</a></h3>
<p>Mapping is itself an instance of a general pattern of computation: iterating
over all elements in a sequence.  To map a function over a sequence, we do not
just select a particular element, but each element in turn.  This pattern is so
common that Python has an additional control statement to process sequential
data: the <tt class="docutils literal">for</tt> statement.</p>
<p>Consider the problem of counting how many times a value appears in a sequence.
We can implement a function to compute this count using a <tt class="docutils literal">while</tt> loop.</p>
<pre class="doctest-block">&gt;&gt;&gt; def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total, index = 0, 0
        while index &lt; len(s):
            if s[index] == value:
                total = total + 1
            index = index + 1
        return total
</pre>
<pre class="doctest-block">&gt;&gt;&gt; count(digits, 8)
2
</pre>
<p>The Python <tt class="docutils literal">for</tt> statement can simplify this function body by iterating over
the element values directly, without introducing the name <tt class="docutils literal">index</tt> at all.
<tt class="docutils literal">For</tt> example (pun intended), we can write:</p>
<pre class="doctest-block">&gt;&gt;&gt; def count(s, value):
        """Count the number of occurrences of value in sequence s."""
        total = 0
        for elem in s:
            if elem == value:
                total = total + 1
        return total
</pre>
<pre class="doctest-block">&gt;&gt;&gt; count(digits, 8)
2
</pre>
<p>A <tt class="docutils literal">for</tt> statement consists of a single clause with the form:</p>
<pre class="literal-block">for &lt;name&gt; in &lt;expression&gt;:
    &lt;suite&gt;
</pre>
<p>A <tt class="docutils literal">for</tt> statement is executed by the following procedure:</p>
<ol class="arabic simple">
<li>Evaluate the header <tt class="docutils literal">&lt;expression&gt;</tt>, which must yield an iterable value.</li>
<li>For each element value in that sequence, in order:<ol class="upperalpha">
<li>Bind <tt class="docutils literal">&lt;name&gt;</tt> to that value in the local environment.</li>
<li>Execute the <tt class="docutils literal">&lt;suite&gt;</tt>.</li>
</ol>
</li>
</ol>
<p>Step 1 refers to an iterable value.  Sequences are iterable, and their elements
are considered in their sequential order.  Python does include other iterable
types, but we will focus on sequences for now; the general definition of the
term "iterable" appears in the section on iterators in Chapter 4.</p>
<p>An important consequence of this evaluation procedure is that <tt class="docutils literal">&lt;name&gt;</tt> will be
bound to the last element of the sequence after the <tt class="docutils literal">for</tt> statement is
executed.  The <tt class="docutils literal">for</tt> loop introduces yet another way in which the local
environment can be updated by a statement.</p>
<p><strong>Sequence unpacking.</strong> A common pattern in programs is to have a sequence of
elements that are themselves sequences, but all of a fixed length.  <tt class="docutils literal">For</tt>
statements may include multiple names in their header to "unpack" each element
sequence into its respective elements.  For example, we may have a sequence of
pairs (that is, two-element tuples),</p>
<pre class="doctest-block">&gt;&gt;&gt; pairs = ((1, 2), (2, 2), (2, 3), (4, 4))
</pre>
<p>and wish to find the number of pairs that have the same first and second element.</p>
<pre class="doctest-block">&gt;&gt;&gt; same_count = 0
</pre>
<p>The following <tt class="docutils literal">for</tt> statement with two names in its header will bind each name
<tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt> to the first and second elements in each pair, respectively.</p>
<pre class="doctest-block">&gt;&gt;&gt; for x, y in pairs:
        if x == y:
            same_count = same_count + 1
</pre>
<pre class="doctest-block">&gt;&gt;&gt; same_count
2
</pre>
<p>This pattern of binding multiple names to multiple values in a fixed-length
sequence is called <em>sequence unpacking</em>; it is the same pattern that we see in
assignment statements that bind multiple names to multiple values.</p>
<p><strong>Ranges.</strong> A <tt class="docutils literal">range</tt> is another built-in type of sequence in Python, which
represents a range of integers.  Ranges are created with the <tt class="docutils literal">range</tt> function,
which takes two integer arguments: the first number and one beyond the last
number in the desired range.</p>
<pre class="doctest-block">&gt;&gt;&gt; range(1, 10)  # Includes 1, but not 10
range(1, 10)
</pre>
<p>Calling the <tt class="docutils literal">tuple</tt> constructor on a range will create a tuple with the same
elements as the range, so that the elements can be easily inspected.</p>
<pre class="doctest-block">&gt;&gt;&gt; tuple(range(5, 8))
(5, 6, 7)
</pre>
<p>If only one argument is given, it is interpreted as one beyond the last value
for a range that starts at 0.</p>
<pre class="doctest-block">&gt;&gt;&gt; tuple(range(4))
(0, 1, 2, 3)
</pre>
<p>Ranges commonly appear as the expression in a <tt class="docutils literal">for</tt> header to specify the
number of times that the suite should be executed:</p>
<pre class="doctest-block">&gt;&gt;&gt; total = 0
&gt;&gt;&gt; for k in range(5, 8):
        total = total + k
</pre>
<pre class="doctest-block">&gt;&gt;&gt; total
18
</pre>
<p>A common convention is to use a single underscore character for the name in the
<tt class="docutils literal">for</tt> header if the name is unused in the suite:</p>
<pre class="literal-block">&gt;&gt;&gt; for _ in range(3):
        print('Go Bears!')

Go Bears!
Go Bears!
Go Bears!
</pre>
<p>Note that an underscore is just another name in the environment as far as the
interpreter is concerned, but has a conventional meaning among programmers that
indicates the name will not appear in any expressions.</p>
</div>
<div class="section" id="sequence-abstraction">
<h3><a class="toc-backref" href="#id15">2.3.5&nbsp;&nbsp;&nbsp;Sequence Abstraction</a></h3>
<p>We have now introduced two types of native data types that implement the
sequence abstraction: tuples and ranges.  Both satisfy the conditions with which
we began this section: length and element selection.  Python includes two more
behaviors of sequence types that extend the sequence abstraction.</p>
<p><strong>Membership.</strong>  A value can be tested for membership in a sequence.  Python has
two operators <tt class="docutils literal">in</tt> and <tt class="docutils literal">not in</tt> that evaluate to <tt class="docutils literal">True</tt> or <tt class="docutils literal">False</tt>
depending on whether an element appears in a sequence.</p>
<pre class="doctest-block">&gt;&gt;&gt; digits
(1, 8, 2, 8)
&gt;&gt;&gt; 2 in digits
True
&gt;&gt;&gt; 1828 not in digits
True
</pre>
<p>All sequences also have methods called <tt class="docutils literal">index</tt> and <tt class="docutils literal">count</tt>, which return the
index of (or count of) a value in a sequence.</p>
<p><strong>Slicing.</strong> Sequences contain smaller sequences within them.  We observed this
property when developing our nested pairs implementation, which decomposed a
sequence into its first element and the rest.  A <em>slice</em> of a sequence is any
span of the original sequence, designated by a pair of integers.  As with the
<tt class="docutils literal">range</tt> constructor, the first integer indicates the starting index of the
slice and the second indicates one beyond the ending index.</p>
<p>In Python, sequence slicing is expressed similarly to element selection, using
square brackets.  A colon separates the starting and ending indices.  Any bound
that is omitted is assumed to be an extreme value:  0 for the starting index,
and the length of the sequence for the ending index.</p>
<pre class="doctest-block">&gt;&gt;&gt; digits[0:2]
(1, 8)
&gt;&gt;&gt; digits[1:]
(8, 2, 8)
</pre>
<p>Enumerating these additional behaviors of the Python sequence abstraction gives
us an opportunity to reflect upon what constitutes a useful data abstraction in
general.  The richness of an abstraction (that is, how many behaviors it
includes) has consequences.  For users of an abstraction, additional behaviors
can be helpful.  On the other hand, satisfying the requirements of a rich
abstraction with a new data type can be challenging.  To ensure that our
implementation of recursive lists supported these additional behaviors would
require some work.  Another negative consequence of rich abstractions is
that they take longer for users to learn.</p>
<p>Sequences have a rich abstraction because they are so ubiquitous in computing
that learning a few complex behaviors is justified.  In general, most
user-defined abstractions should be kept as simple as possible.</p>
<p><strong>Further reading.</strong> Slice notation admits a variety of special cases, such as
negative starting values, ending values, and step sizes.  A complete description
appears in the subsection called <a class="reference external" href="http://diveintopython3.ep.io/native-datatypes.html#slicinglists">slicing a list</a> in Dive Into
Python 3.  In this chapter, we will only use the basic features described above.</p>
</div>
<div class="section" id="strings">
<h3><a class="toc-backref" href="#id16">2.3.6&nbsp;&nbsp;&nbsp;Strings</a></h3>
<p>Text values are perhaps more fundamental to computer science than even numbers.
As a case in point, Python programs are written and stored as text.  The native
data type for text in Python is called a string, and corresponds to the
constructor <tt class="docutils literal">str</tt>.</p>
<p>There are many details of how strings are represented, expressed, and
manipulated in Python. Strings are another example of a rich abstraction, one
which requires a substantial commitment on the part of the programmer to master.
This section serves as a condensed introduction to essential string behaviors.</p>
<p>String literals can express arbitrary text, surrounded by either single or
double quotation marks.</p>
<pre class="doctest-block">&gt;&gt;&gt; 'I am string!'
'I am string!'
&gt;&gt;&gt; "I've got an apostrophe"
"I've got an apostrophe"
&gt;&gt;&gt; '您好'
'您好'
</pre>
<p>We have seen strings already in our code, as docstrings, in calls to <tt class="docutils literal">print</tt>,
and as error messages in <tt class="docutils literal">assert</tt> statements.</p>
<p>Strings satisfy the two basic conditions of a sequence that we introduced at the
beginning of this section: they have a length and they support element
selection.</p>
<pre class="doctest-block">&gt;&gt;&gt; city = 'Berkeley'
&gt;&gt;&gt; len(city)
8
&gt;&gt;&gt; city[3]
'k'
</pre>
<p>The elements of a string are themselves strings that have only a single
character.  A character is any single letter of the alphabet, punctuation
mark, or other symbol.  Unlike many other programming languages, Python does not
have a separate character type; any text is a string, and strings that represent
single characters have a length of 1.</p>
<p>Like tuples, strings can also be combined via addition and multiplication.</p>
<pre class="doctest-block">&gt;&gt;&gt; 'Berkeley' + ', CA'
'Berkeley, CA'
&gt;&gt;&gt; 'Shabu ' * 2
'Shabu Shabu '
</pre>
<p><strong>Membership.</strong> The behavior of strings diverges from other sequence
types in Python.  The string abstraction does not conform to the full sequence
abstraction that we described for tuples and ranges.  In particular, the
membership operator <tt class="docutils literal">in</tt> applies to strings, but has an entirely different
behavior than when it is applied to sequences.  It matches substrings rather
than elements.</p>
<pre class="doctest-block">&gt;&gt;&gt; 'here' in "Where's Waldo?"
True
</pre>
<p>Likewise, the <tt class="docutils literal">count</tt> and <tt class="docutils literal">index</tt> methods on strings take substrings as
arguments, rather than single-character elements.  The behavior of <tt class="docutils literal">count</tt> is
particularly nuanced; it counts the number of non-overlapping occurrences of a
substring in a string.</p>
<pre class="doctest-block">&gt;&gt;&gt; 'Mississippi'.count('i')
4
&gt;&gt;&gt; 'Mississippi'.count('issi')
1
</pre>
<p><strong>Multiline Literals.</strong> Strings aren't limited to a single line. Triple quotes
delimit string literals that span multiple lines.  We have used this triple
quoting extensively already for docstrings.</p>
<pre class="doctest-block">&gt;&gt;&gt; """The Zen of Python
claims, Readability counts.
Read more: import this."""
'The Zen of Python\nclaims, "Readability counts."\nRead more: import this.'
</pre>
<p>In the printed result above, the <tt class="docutils literal">\n</tt> (pronounced "<em>backslash en</em>") is a
single element that represents a new line.  Although it appears as two
characters (backslash and "n"), it is considered a single character for the
purposes of length and element selection.</p>
<p><strong>String Coercion.</strong> A string can be created from any object in Python by
calling the <tt class="docutils literal">str</tt> constructor function with an object value as its argument.
This feature of strings is useful for constructing descriptive strings from
objects of various types.</p>
<pre class="doctest-block">&gt;&gt;&gt; str(2) + ' is an element of ' + str(digits)
'2 is an element of (1, 8, 2, 8)'
</pre>
<p>The mechanism by which a single <tt class="docutils literal">str</tt> function can apply to any type of
argument and return an appropriate value is the subject of the later section on
generic functions.</p>
<p><strong>Methods.</strong> The behavior of strings in Python is extremely productive because
of a rich set of methods for returning string variants and searching for
contents. A few of these methods are introduced below by example.</p>
<pre class="doctest-block">&gt;&gt;&gt; '1234'.isnumeric()
True
&gt;&gt;&gt; 'rOBERT dE nIRO'.swapcase()
'Robert De Niro'
&gt;&gt;&gt; 'snakeyes'.upper().endswith('YES')
True
</pre>
<p><strong>Further reading.</strong> Encoding text in computers is a complex topic.  In this
chapter, we will abstract away the details of how strings are represented.
However, for many applications, the particular details of how strings are
encoded by computers is essential knowledge.     <a class="reference external" href="http://diveintopython3.ep.io/strings.html">Sections 4.1-4.3 of Dive Into
Python 3</a> provides a description of
character encodings and Unicode.</p>
</div>
<div class="section" id="conventional-interfaces">
<h3><a class="toc-backref" href="#id17">2.3.7&nbsp;&nbsp;&nbsp;Conventional Interfaces</a></h3>
<p>In working with compound data, we've stressed how data abstraction permits us to
design programs without becoming enmeshed in the details of data
representations, and how abstraction preserves for us the flexibility to
experiment with alternative representations. In this section, we introduce
another powerful design principle for working with data structures --- the use of
<em>conventional interfaces</em>.</p>
<p>A conventional interface is a data format that is shared across many modular
components, which can be mixed and matched to perform data processing. For
example, if we have several functions that all take a sequence as an argument
and return a sequence as a value, then we can apply each to the output of the
next in any order we choose.  In this way, we can create a complex process by
chaining together a pipeline of functions, each of which is simple and focused.</p>
<p>This section has a dual purpose: to introduce the idea of organizing a program
around a conventional interface, and to demonstrate examples of modular sequence
processing.</p>
<p>Consider these two problems, which appear at first to be related only in their
use of sequences:</p>
<ol class="arabic simple">
<li>Sum the even members of the first <tt class="docutils literal">n</tt> Fibonacci numbers.</li>
<li>List the letters in the acronym for a name, which includes the first letter
of each capitalized word.</li>
</ol>
<p>These problems are related because they can be decomposed into simple operations
that take sequences as input and yield sequences as output. Moreover, those
operations are instances of general methods of computation over sequences. Let's
consider the first problem.  It can be decomposed into the following steps:</p>
<pre class="literal-block"> enumerate     map    filter  accumulate
-----------    ---    ------  ----------
naturals(n)    fib    iseven     sum
</pre>
<p>The <tt class="docutils literal">fib</tt> function below computes Fibonacci numbers (now updated from the
definition in Chapter 1 with a <tt class="docutils literal">for</tt> statement),</p>
<pre class="doctest-block">&gt;&gt;&gt; def fib(k):
        """Compute the kth Fibonacci number."""
        prev, curr = 1, 0  # curr is the first Fibonacci number.
        for _ in range(k - 1):
             prev, curr = curr, prev + curr
        return curr
</pre>
<p>and a predicate <tt class="docutils literal">iseven</tt> can be defined using the integer remainder operator,
<tt class="docutils literal">%</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def iseven(n):
        return n % 2 == 0
</pre>
<p>The functions <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt> are operations on sequences.  We have
already encountered <tt class="docutils literal">map</tt>, which applies a function to each element in a
sequence and collects the results.  The <tt class="docutils literal">filter</tt> function takes a sequence and
returns those elements of a sequence for which a predicate is true. Both of
these functions return intermediate objects, <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt> objects,
which are iterable objects that can be converted into tuples or summed.</p>
<pre class="doctest-block">&gt;&gt;&gt; nums = (5, 6, -7, -8, 9)
&gt;&gt;&gt; tuple(filter(iseven, nums))
(6, -8)
&gt;&gt;&gt; sum(map(abs, nums))
35
</pre>
<p>Now we can implement <tt class="docutils literal">even_fib</tt>, the solution to our first problem, in terms
of <tt class="docutils literal">map</tt>, <tt class="docutils literal">filter</tt>, and <tt class="docutils literal">sum</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def sum_even_fibs(n):
        """Sum the first n even Fibonacci numbers."""
        return sum(filter(iseven, map(fib, range(1, n+1))))
</pre>
<pre class="doctest-block">&gt;&gt;&gt; sum_even_fibs(20)
3382
</pre>
<p>Now, let's consider the second problem.  It can also be decomposed as a pipeline
of sequence operations that include <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt>:</p>
<pre class="literal-block">enumerate  filter   map   accumulate
---------  ------  -----  ----------
  words    iscap   first    tuple
</pre>
<p>The words in a string can be enumerated via the <tt class="docutils literal">split</tt> method of a string
object, which by default splits on spaces.</p>
<pre class="doctest-block">&gt;&gt;&gt; tuple('Spaces between words'.split())
('Spaces', 'between', 'words')
</pre>
<p>The first letter of a word can be retrieved using the selection operator, and a
predicate that determines if a word is capitalized can be defined using the
built-in predicate <tt class="docutils literal">isupper</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def first(s):
        return s[0]
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def iscap(s):
        return len(s) &gt; 0 and s[0].isupper()
</pre>
<p>At this point, our acronym function can be defined via <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def acronym(name):
        """Return a tuple of the letters that form the acronym for name."""
        return tuple(map(first, filter(iscap, name.split())))
</pre>
<pre class="doctest-block">&gt;&gt;&gt; acronym('University of California Berkeley Undergraduate Graphics Group')
('U', 'C', 'B', 'U', 'G', 'G')
</pre>
<p>These similar solutions to rather different problems show how to combine general
components that operate on the conventional interface of a sequence using the
general computational patterns of mapping, filtering, and accumulation.  The
sequence abstraction allows us to specify these solutions concisely.</p>
<p>Expressing programs as sequence operations helps us design programs that are
modular. That is, our designs are constructed by combining relatively
independent pieces, each of which transforms a sequence. In general, we can
encourage modular design by providing a library of standard components together
with a conventional interface for connecting the components in flexible ways.</p>
<p><strong>Generator expressions.</strong> The Python language includes a second approach to
processing sequences, called <em>generator expressions</em>. which provide similar
functionality to <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt>, but may require fewer function
definitions.</p>
<p>Generator expressions combine the ideas of filtering and mapping together into a
single expression type with the following form:</p>
<pre class="literal-block">&lt;map expression&gt; for &lt;name&gt; in &lt;sequence expression&gt; if &lt;filter expression&gt;
</pre>
<p>To evaluate a generator expression, Python evaluates the <tt class="docutils literal">&lt;sequence
expression&gt;</tt>, which must return an iterable value.  Then, for each element in
order, the element value is bound to <tt class="docutils literal">&lt;name&gt;</tt>, the filter expression is
evaluated, and if it yields a true value, the map expression is evaluated.</p>
<p>The result value of evaluating a generator expression is itself an iterable
value.  Accumulation functions like <tt class="docutils literal">tuple</tt>, <tt class="docutils literal">sum</tt>, <tt class="docutils literal">max</tt>, and <tt class="docutils literal">min</tt> can
take this returned object as an argument.</p>
<pre class="doctest-block">&gt;&gt;&gt; def acronym(name):
        return tuple(w[0] for w in name.split() if iscap(w))
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def sum_even_fibs(n):
        return sum(fib(k) for k in range(1, n+1) if fib(k) % 2 == 0)
</pre>
<p>Generator expressions are specialized syntax that utilizes the conventional
interface of iterable values, such as sequences. These expressions subsume most
of the functionality of <tt class="docutils literal">map</tt> and <tt class="docutils literal">filter</tt>, but avoid actually creating the
function values that are applied (or, incidentally, creating the environment
frames required to apply those functions).</p>
<p><strong>Reduce.</strong> In our examples we used specific functions to accumulate
results, either <tt class="docutils literal">tuple</tt> or <tt class="docutils literal">sum</tt>.  Functional programming languages
(including Python) include general higher-order accumulators that go by various
names.  Python includes <tt class="docutils literal">reduce</tt> in the <tt class="docutils literal">functools</tt> module, which applies a
two-argument function cumulatively to the elements of a sequence from left to
right, to reduce a sequence to a value.  The following expression computes 5
factorial.</p>
<pre class="doctest-block">&gt;&gt;&gt; from operator import mul
&gt;&gt;&gt; from functools import reduce
&gt;&gt;&gt; reduce(mul, (1, 2, 3, 4, 5))
120
</pre>
<p>Using this more general form of accumulation, we can also compute the product
of even Fibonacci numbers, in addition to the sum, using sequences as a
conventional interface.</p>
<pre class="doctest-block">&gt;&gt;&gt; def product_even_fibs(n):
        """Return the product of the first n even Fibonacci numbers, except 0."""
        return reduce(mul, filter(iseven, map(fib, range(2, n+1))))
</pre>
<pre class="doctest-block">&gt;&gt;&gt; product_even_fibs(20)
123476336640
</pre>
<p>The combination of higher order procedures corresponding to <tt class="docutils literal">map</tt>, <tt class="docutils literal">filter</tt>,
and <tt class="docutils literal">reduce</tt> will appear again in Chapter 4, when we consider methods for
distributing computation across multiple computers.</p>
</div>
</div>
<div class="section" id="mutable-data">
<h2><a class="toc-backref" href="#id18">2.4&nbsp;&nbsp;&nbsp;Mutable Data</a></h2>
<p>We have seen how abstraction is vital in helping us to cope with the complexity
of large systems.  Effective program synthesis also requires organizational
principles that can guide us in formulating the overall design of a program. In
particular, we need strategies to help us structure large systems so that they
will be <em>modular</em>, that is, so that they can be divided "naturally" into
coherent parts that can be separately developed and maintained.</p>
<p>One powerful technique for creating modular programs is to introduce new kinds
of data that may change state over time.  In this way, a single data object can
represent something that evolves independently of the rest of the program. The
behavior of a changing object may be influenced by its history, just like an
entity in the world. Adding state to data is an essential ingredient of our
final destination in this chapter: object-oriented programming.</p>
<p>The native data types we have introduced so far --- numbers, Booleans, tuples,
ranges, and strings --- are all types of <em>immutable</em> objects. While names may
change bindings to different values in the environment during the course of
execution, the values themselves do not change.  In this section, we will
introduce a collection of <em>mutable</em> data types. Mutable objects can change
throughout the execution of a program.</p>
<div class="section" id="local-state">
<h3><a class="toc-backref" href="#id19">2.4.1&nbsp;&nbsp;&nbsp;Local State</a></h3>
<p>Our first example of a mutable object will be a function that has local state.
That state will change during the course of execution of a program.</p>
<p>To illustrate what we mean by having a function with local state, let us model
the situation of withdrawing money from a bank account. We will do so by
creating a function called <tt class="docutils literal">withdraw</tt>, which takes as its argument an amount
to be withdrawn. If there is enough money in the account to accommodate the
withdrawal, then <tt class="docutils literal">withdraw</tt> should return the balance remaining after the
withdrawal. Otherwise, <tt class="docutils literal">withdraw</tt> should return the message <tt class="docutils literal">'Insufficient
funds'</tt>.  For example, if we begin with $100 in the account, we would like to
obtain the following sequence of return values by calling withdraw:</p>
<pre class="doctest-block">&gt;&gt;&gt; withdraw(25)
75
&gt;&gt;&gt; withdraw(25)
50
&gt;&gt;&gt; withdraw(60)
'Insufficient funds'
&gt;&gt;&gt; withdraw(15)
35
</pre>
<p>Observe that the expression <tt class="docutils literal">withdraw(25)</tt>, evaluated twice, yields different
values. This is a new kind of behavior for a user-defined function: it is
non-pure. Calling the function not only returns a value, but also has the side
effect of changing the function in some way, so that the next call with the same
argument will return a different result.  All of our user-defined functions so
far have been pure functions, unless they called a non-pure built-in function.
They have remained pure because they have not been allowed to make any changes
outside of their local environment frame!</p>
<p>For <tt class="docutils literal">withdraw</tt> to make sense, it must be created with an initial account
balance. The function <tt class="docutils literal">make_withdraw</tt> is a higher-order function that takes a
starting balance as an argument.  The function <tt class="docutils literal">withdraw</tt> is its return value.</p>
<pre class="doctest-block">&gt;&gt;&gt; withdraw = make_withdraw(100)
</pre>
<p>An implementation of <tt class="docutils literal">make_withdraw</tt> requires a new kind of statement: a
<tt class="docutils literal">nonlocal</tt> statement.  When we call <tt class="docutils literal">make_withdraw</tt>, we bind the name
<tt class="docutils literal">balance</tt> to the initial amount.  We then define and return a local function,
<tt class="docutils literal">withdraw</tt>, which updates and returns the value of <tt class="docutils literal">balance</tt> when called.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_withdraw(balance):
        """Return a withdraw function that draws down balance with each call."""
        def withdraw(amount):
            nonlocal balance                 # Declare the name "balance" nonlocal
            if amount &gt; balance:
                return 'Insufficient funds'
            balance = balance - amount       # Re-bind the existing balance name
            return balance
        return withdraw
</pre>
<p>The novel part of this implementation is the <tt class="docutils literal">nonlocal</tt> statement, which
mandates that whenever we change the binding of the name <tt class="docutils literal">balance</tt>, the
binding is changed in the first frame in which <tt class="docutils literal">balance</tt> is already bound.
Recall that without the <tt class="docutils literal">nonlocal</tt> statement, an assignment statement would
always bind a name in the first frame of the environment.  The <tt class="docutils literal">nonlocal</tt>
statement indicates that the name appears somewhere in the environment other
than the first (local) frame or the last (global) frame.</p>
<p>We can visualize these changes with environment diagrams.  The following
environment diagrams illustrate the effects of each call, starting with
the definition above.  We abbreviate away code in the function values and
expression trees that isn't central to our discussion.</p>
<div class="figure">
<img alt="img/nonlocal_def.png" src="02_files/nonlocal_def.png">
</div>
<p>Our definition statement has the usual effect: it creates a new user-defined
function and binds the name <tt class="docutils literal">make_withdraw</tt> to that function in the global
frame.</p>
<p>Next, we call <tt class="docutils literal">make_withdraw</tt> with an initial balance argument of <tt class="docutils literal">20</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; wd = make_withdraw(20)
</pre>
<p>This assignment statement binds the name <tt class="docutils literal">wd</tt> to the returned function in the
global frame.</p>
<div class="figure">
<img alt="img/nonlocal_assign.png" src="02_files/nonlocal_assign.png">
</div>
<p>The returned function, (intrinsically) called <em>withdraw</em>, is associated with the
local environment for the <em>make_withdraw</em> invocation in which it was defined.
The name <tt class="docutils literal">balance</tt> is bound in this local environment.  Crucially, there will
only be this single binding for the name <tt class="docutils literal">balance</tt> throughout the rest of this
example.</p>
<p>Next, we evaluate an expression that calls <em>withdraw</em> on an amount <tt class="docutils literal">5</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; wd(5)
15
</pre>
<p>The name <tt class="docutils literal">wd</tt> is bound to the <em>withdraw</em> function, so the body of <em>withdraw</em>
is evaluated in a new environment that extends the environment in which
<em>withdraw</em> was defined.  Tracing the effect of evaluating <em>withdraw</em> illustrates
the effect of a <tt class="docutils literal">nonlocal</tt> statement in Python.</p>
<div class="figure">
<img alt="img/nonlocal_call.png" src="02_files/nonlocal_call.png">
</div>
<p>The assignment statement in <em>withdraw</em> would normally create a new binding for
<tt class="docutils literal">balance</tt> in <em>withdraw</em>'s local frame.  Instead, because of the <tt class="docutils literal">nonlocal</tt>
statement, the assignment finds the first frame in which <tt class="docutils literal">balance</tt> was
already defined, and it rebinds the name in that frame.  If <tt class="docutils literal">balance</tt> had not
previously been bound to a value, then the <tt class="docutils literal">nonlocal</tt> statement would have
given an error.</p>
<p>By virtue of changing the binding for <tt class="docutils literal">balance</tt>, we have changed the
<em>withdraw</em> function as well.  The next time <em>withdraw</em> is called, the name
<tt class="docutils literal">balance</tt> will evaluate to <tt class="docutils literal">15</tt> instead of <tt class="docutils literal">20</tt>.</p>
<p>When we call <tt class="docutils literal">wd</tt> a second time,</p>
<pre class="doctest-block">&gt;&gt;&gt; wd(3)
12
</pre>
<p>we see that the changes to the value bound to the name <tt class="docutils literal">balance</tt> are
cumulative across the two calls.</p>
<div class="figure">
<img alt="img/nonlocal_recall.png" src="02_files/nonlocal_recall.png">
</div>
<p>Here, the second call to <em>withdraw</em> did create a second local frame, as usual.
However, both <em>withdraw</em> frames extend the environment for <em>make_withdraw</em>,
which contains the binding for <tt class="docutils literal">balance</tt>.  Hence, they share that particular
name binding.  Calling <em>withdraw</em> has the side effect of altering the
environment that will be extended by future calls to <em>withdraw</em>.</p>
<p><strong>Practical guidance.</strong> By introducing <tt class="docutils literal">nonlocal</tt> statements, we have created
a dual role for assignment statements.  Either they change local bindings, or
they change nonlocal bindings.  In fact, assignment statements already had a
dual role: they either created new bindings or re-bound existing names.  The
many roles of Python assignment can obscure the effects of executing an
assignment statement.  It is up to you as a programmer to document your code
clearly so that the effects of assignment can be understood by others.</p>
</div>
<div class="section" id="the-benefits-of-non-local-assignment">
<h3><a class="toc-backref" href="#id20">2.4.2&nbsp;&nbsp;&nbsp;The Benefits of Non-Local Assignment</a></h3>
<p>Non-local assignment is an important step on our path to viewing a program as a
collection of independent and autonomous <em>objects</em>, which interact with each
other but each manage their own internal state.</p>
<p>In particular, non-local assignment has given us the ability to maintain some
state that is local to a function, but evolves over successive calls to that
function.  The <tt class="docutils literal">balance</tt> associated with a particular withdraw function is
shared among all calls to that function. However, the binding for balance
associated with an instance of withdraw is inaccessible to the rest of the
program.  Only <em>withdraw</em> is associated with the frame for <em>make_withdraw</em> in
which it was defined.  If <em>make_withdraw</em> is called again, then it will create a
separate frame with a separate binding for <tt class="docutils literal">balance</tt>.</p>
<p>We can continue our example to illustrate this point.  A second call to
<em>make_withdraw</em> returns a second <em>withdraw</em> function that is associated with yet
another environment.</p>
<pre class="doctest-block">&gt;&gt;&gt; wd2 = make_withdraw(7)
</pre>
<p>This second <em>withdraw</em> function is bound to the name <tt class="docutils literal">wd2</tt> in the global
frame.  We've abbreviated the line that represents this binding with an
asterisk.  Now, we see that there are in fact two bindings for the name
<tt class="docutils literal">balance</tt>.  The name <tt class="docutils literal">wd</tt> is still bound to a <em>withdraw</em> function with a
balance of <tt class="docutils literal">12</tt>, while <tt class="docutils literal">wd2</tt> is bound to a new <em>withdraw</em> function with a
balance of <tt class="docutils literal">7</tt>.</p>
<div class="figure">
<img alt="img/nonlocal_def2.png" src="02_files/nonlocal_def2.png">
</div>
<p>Finally, we call the second <em>withdraw</em> bound to <tt class="docutils literal">wd2</tt>:</p>
<pre class="doctest-block">&gt;&gt;&gt; wd2(6)
1
</pre>
<p>This call changes the binding of its nonlocal <tt class="docutils literal">balance</tt> name, but does not
affect the first <em>withdraw</em> bound to the name <tt class="docutils literal">wd</tt> in the global frame.</p>
<div class="figure">
<img alt="img/nonlocal_call2.png" src="02_files/nonlocal_call2.png">
</div>
<p>In this way, each instance of <em>withdraw</em> is maintaining its own balance state,
but that state is inaccessible to any other function in the program.  Viewing
this situation at a higher level, we have created an abstraction of a bank
account that manages its own internals but behaves in a way that models accounts
in the world: it changes over time based on its own history of withdrawal
requests.</p>
</div>
<div class="section" id="the-cost-of-non-local-assignment">
<h3><a class="toc-backref" href="#id21">2.4.3&nbsp;&nbsp;&nbsp;The Cost of Non-Local Assignment</a></h3>
<p>Our environment model of computation cleanly extends to explain the effects of
non-local assignment.  However, non-local assignment introduces some important
nuances in the way we think about names and values.</p>
<p>Previously, our values did not change; only our names and bindings changed.
When two names <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> were both bound to the value <tt class="docutils literal">4</tt>, it did not
matter whether they were bound to the same <tt class="docutils literal">4</tt> or different <tt class="docutils literal">4</tt>'s.  As far
as we could tell, there was only one <tt class="docutils literal">4</tt> object that never changed.</p>
<p>However, functions with state do not behave this way.  When two names <tt class="docutils literal">wd</tt>
and <tt class="docutils literal">wd2</tt> are both bound to a <em>withdraw</em> function, it <em>does</em> matter whether
they are bound to the same function or different instances of that function.
Consider the following example, which contrasts the one we just analyzed.</p>
<pre class="doctest-block">&gt;&gt;&gt; wd = make_withdraw(12)
&gt;&gt;&gt; wd2 = wd
&gt;&gt;&gt; wd2(1)
11
&gt;&gt;&gt; wd(1)
10
</pre>
<p>In this case, calling the function named by <tt class="docutils literal">wd2</tt> did change the value of the
function named by <tt class="docutils literal">wd</tt>, because both names refer to the same function.  The
environment diagram after these statements are executed shows this fact.</p>
<div class="figure">
<img alt="img/nonlocal_corefer.png" src="02_files/nonlocal_corefer.png">
</div>
<p>It is not unusual for two names to co-refer to the same value in the world, and
so it is in our programs.  But, as values change over time, we must be very
careful to understand the effect of a change on other names that might refer to
those values.</p>
<p>The key to correctly analyzing code with non-local assignment is to remember
that only function calls can introduce new frames.  Assignment statements always
change bindings in existing frames.  In this case, unless <em>make_withdraw</em> is
called twice, there can be only one binding for <tt class="docutils literal">balance</tt>.</p>
<p><strong>Sameness and change.</strong> These subtleties arise because, by introducing non-pure
functions that change the non-local environment, we have changed the nature of
expressions.  An expression that contains only pure function calls is
<em>referentially transparent</em>; its value does not change if we substitute one of
its subexpression with the value of that subexpression.</p>
<p>Re-binding operations violate the conditions of referential transparency because
they do more than return a value; they change the environment.  When we
introduce arbitrary re-binding, we encounter a thorny epistemological issue:
what it means for two values to be the same. In our environment model of
computation, two separately defined functions are not the same, because changes
to one may not be reflected in the other.</p>
<p>In general, so long as we never modify data objects, we can regard a compound
data object to be precisely the totality of its pieces. For example, a rational
number is determined by giving its numerator and its denominator. But this view
is no longer valid in the presence of change, where a compound data object has
an "identity" that is something different from the pieces of which it is
composed. A bank account is still "the same" bank account even if we change the
balance by making a withdrawal; conversely, we could have two bank accounts that
happen to have the same balance, but are different objects.</p>
<p>Despite the complications it introduces, non-local assignment is a powerful tool
for creating modular programs. Different parts of a program, which correspond to
different environment frames, can evolve separately throughout program
execution.  Moreover, using functions with local state, we are able to implement
mutable data types.  In the remainder of this section, we introduce some of the
most useful built-in data types in Python, along with methods for implementing
those data types using functions with non-local assignment.</p>
</div>
<div class="section" id="lists">
<h3><a class="toc-backref" href="#id22">2.4.4&nbsp;&nbsp;&nbsp;Lists</a></h3>
<p>The <tt class="docutils literal">list</tt> is Python's most useful and flexible sequence type.  A list is
similar to a tuple, but it is mutable.  Method calls and assignment statements
can change the contents of a list.</p>
<p>We can introduce many list editing operations through an example that
illustrates the history of playing cards (drastically simplified). Comments in
the examples describe the effect of each method invocation.</p>
<p>Playing cards were invented in China, perhaps around the 9th century. An early
deck had three suits, which corresponded to denominations of money.</p>
<pre class="doctest-block">&gt;&gt;&gt; chinese_suits = ['coin', 'string', 'myriad']  # A list literal
&gt;&gt;&gt; suits = chinese_suits                         # Two names refer to the same list
</pre>
<p>As cards migrated to Europe (perhaps through Egypt), only the suit of coins
remained in Spanish decks (<em>oro</em>).</p>
<pre class="doctest-block">&gt;&gt;&gt; suits.pop()             # Removes and returns the final element
'myriad'
&gt;&gt;&gt; suits.remove('string')  # Removes the first element that equals the argument
</pre>
<p>Three more suits were added (they evolved in name and design over time),</p>
<pre class="doctest-block">&gt;&gt;&gt; suits.append('cup')              # Add an element to the end
&gt;&gt;&gt; suits.extend(['sword', 'club'])  # Add all elements of a list to the end
</pre>
<p>and Italians called swords <em>spades</em>.</p>
<pre class="doctest-block">&gt;&gt;&gt; suits[2] = 'spade'  # Replace an element
</pre>
<p>giving the suits of a traditional Italian deck of cards.</p>
<pre class="doctest-block">&gt;&gt;&gt; suits
['coin', 'cup', 'spade', 'club']
</pre>
<p>The French variant that we use today in the U.S. changes the first two:</p>
<pre class="doctest-block">&gt;&gt;&gt; suits[0:2] = ['heart', 'diamond']  # Replace a slice
&gt;&gt;&gt; suits
['heart', 'diamond', 'spade', 'club']
</pre>
<p>Methods also exist for inserting, sorting, and reversing lists.  All of these
<em>mutation operations</em> change the value of the list; they do not create new list
objects.</p>
<p><strong>Sharing and Identity.</strong> Because we have been changing a single list rather
than creating new lists, the object bound to the name <tt class="docutils literal">chinese_suits</tt> has also
changed, because it is the same list object that was bound to <tt class="docutils literal">suits</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; chinese_suits  # This name co-refers with "suits" to the same list
['heart', 'diamond', 'spade', 'club']
</pre>
<p>Lists can be copied using the <tt class="docutils literal">list</tt> constructor function.  Changes to one
list do not affect another, unless they share structure.</p>
<pre class="doctest-block">&gt;&gt;&gt; nest = list(suits)  # Bind "nest" to a second list with the same elements
&gt;&gt;&gt; nest[0] = suits     # Create a nested list
</pre>
<p>After this final assignment, we are left with the following environment, where
lists are represented using box-and-pointer notation.</p>
<div class="figure">
<img alt="img/lists.png" src="02_files/lists.png">
</div>
<p>According to this environment, changing the list referenced by <tt class="docutils literal">suits</tt> will
affect the nested list that is the first element of <tt class="docutils literal">nest</tt>, but not the other
elements.</p>
<pre class="doctest-block">&gt;&gt;&gt; suits.insert(2, 'Joker')  # Insert an element at index 2, shifting the rest
&gt;&gt;&gt; nest
[['heart', 'diamond', 'Joker', 'spade', 'club'], 'diamond', 'spade', 'club']
</pre>
<p>And likewise, undoing this change in the first element of <tt class="docutils literal">nest</tt> will change
<tt class="docutils literal">suit</tt> as well.</p>
<pre class="doctest-block">&gt;&gt;&gt; nest[0].pop(2)
'Joker'
&gt;&gt;&gt; suits
['heart', 'diamond', 'spade', 'club']
</pre>
<p>As a result of this last invocation of the <tt class="docutils literal">pop</tt> method, we return to the
environment depicted above.</p>
<p>Because two lists may have the same contents but in fact be different lists, we
require a means to test whether two objects are the same.  Python includes two
comparison operators, called <tt class="docutils literal">is</tt> and <tt class="docutils literal">is not</tt>, that test whether two
expressions in fact evaluate to the identical object.  Two objects are identical
if they are equal in their current value, and any change to one will always be
reflected in the other. Identity is a stronger condition than equality.</p>
<pre class="doctest-block">&gt;&gt;&gt; suits is nest[0]
True
&gt;&gt;&gt; suits is ['heart', 'diamond', 'spade', 'club']
False
&gt;&gt;&gt; suits == ['heart', 'diamond', 'spade', 'club']
True
</pre>
<p>The final two comparisons illustrate the difference between <tt class="docutils literal">is</tt> and <tt class="docutils literal">==</tt>.
The former checks for identity, while the latter checks for the equality of
contents.</p>
<p><strong>List comprehensions.</strong> A list comprehension uses an extended syntax for
creating lists, analogous to the syntax of generator expressions.</p>
<p>For example, the <tt class="docutils literal">unicodedata</tt> module tracks the official names of every
character in the Unicode alphabet.  We can look up the characters corresponding
to names, including those for card suits.</p>
<pre class="doctest-block">&gt;&gt;&gt; from unicodedata import lookup
&gt;&gt;&gt; [lookup('WHITE ' + s.upper() + ' SUIT') for s in suits]
['♡', '♢', '♤', '♧']
</pre>
<p>List comprehensions reinforce the paradigm of data processing using the
conventional interface of sequences, as <tt class="docutils literal">list</tt> is a sequence data type.</p>
<p><strong>Further reading.</strong> Dive Into Python 3 has a chapter on <a class="reference external" href="http://diveintopython3.ep.io/comprehensions.html">comprehensions</a> that includes examples of how
to navigate a computer's file system using Python.  The chapter introduces the
<tt class="docutils literal">os</tt> module, which for instance can list the contents of directories.  This
material is not part of the course, but recommended for anyone who wants to
increase his or her Python expertise.</p>
<p><strong>Implementation.</strong> Lists are sequences, like tuples.  The Python language does
not give us access to the implementation of lists, only to the sequence
abstraction and the mutation methods we have introduced in this section.  To
overcome this language-enforced abstraction barrier, we can develop a
functional implementation of lists, again using a recursive representation. This
section also has a second purpose: to further our understanding of dispatch
functions.</p>
<p>We will implement a list as a function that has a recursive list as its local
state.  Lists need to have an identity, like any mutable value.  In particular,
we cannot use <tt class="docutils literal">None</tt> to represent an empty mutable list, because two empty
lists are not identical values (e.g., appending to one does not append to the
other), but <tt class="docutils literal">None is None</tt>.  On the other hand, two different functions that
each have <tt class="docutils literal">empty_rlist</tt> as their local state will suffice to distinguish two
empty lists.</p>
<p>Our mutable list is a dispatch function, just as our functional implementation
of a pair was a dispatch function.  It checks the input "message" against known
messages and takes an appropriate action for each different input.  Our mutable
list responds to five different messages.  The first two implement the behaviors
of the sequence abstraction.  The next two add or remove the first element of
the list.  The final message returns a string representation of the whole list
contents.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_mutable_rlist():
        """Return a functional implementation of a mutable recursive list."""
        contents = empty_rlist
        def dispatch(message, value=None):
            nonlocal contents
            if message == 'len':
                return len_rlist(contents)
            elif message == 'getitem':
                return getitem_rlist(contents, value)
            elif message == 'push_first':
                contents = make_rlist(value, contents)
            elif message == 'pop_first':
                f = first(contents)
                contents = rest(contents)
                return f
            elif message == 'str':
                return str(contents)
        return dispatch
</pre>
<p>We can also add a convenience function to construct a functionally implemented
recursive list from any built-in sequence, simply by adding each element in
reverse order.</p>
<pre class="doctest-block">&gt;&gt;&gt; def to_mutable_rlist(source):
        """Return a functional list with the same contents as source."""
        s = make_mutable_rlist()
        for element in reversed(source):
            s('push_first', element)
        return s
</pre>
<p>In the definition above, the function <tt class="docutils literal">reversed</tt> takes and returns an iterable
value; it is another example of a function that uses the conventional interface
of sequences.</p>
<p>At this point, we can construct a functionally implemented lists.  Note that
the list itself is a function.</p>
<pre class="doctest-block">&gt;&gt;&gt; s = to_mutable_rlist(suits)
&gt;&gt;&gt; type(s)
&lt;class 'function'&gt;
&gt;&gt;&gt; s('str')
"('heart', ('diamond', ('spade', ('club', None))))"
</pre>
<p>In addition, we can pass messages to the list <tt class="docutils literal">s</tt> that change its contents,
for instance removing the first element.</p>
<pre class="doctest-block">&gt;&gt;&gt; s('pop_first')
'heart'
&gt;&gt;&gt; s('str')
"('diamond', ('spade', ('club', None)))"
</pre>
<p>In principle, the operations <tt class="docutils literal">push_first</tt> and <tt class="docutils literal">pop_first</tt> suffice to make
arbitrary changes to a list.  We can always empty out the list entirely and then
replace its old contents with the desired result.</p>
<p><strong>Message passing.</strong> Given some time, we could implement the many useful
mutation operations of Python lists, such as <tt class="docutils literal">extend</tt> and <tt class="docutils literal">insert</tt>.  We
would have a choice: we could implement them all as functions, which use the
existing messages <tt class="docutils literal">pop_first</tt> and <tt class="docutils literal">push_first</tt> to make all changes.
Alternatively, we could add additional <tt class="docutils literal">elif</tt> clauses to the body of
<tt class="docutils literal">dispatch</tt>, each checking for a message (e.g.,  <tt class="docutils literal">'extend'</tt>) and applying the
appropriate change to <tt class="docutils literal">contents</tt> directly.</p>
<p>This second approach, which encapsulates the logic for all operations on a data
value within one function that responds to different messages, is called message
passing.  A program that uses message passing defines dispatch functions, each
of which may have local state, and organizes computation by passing "messages"
as the first argument to those functions.  The messages are strings that
correspond to particular behaviors.</p>
<p>One could imagine that enumerating all of these messages by name in the body of
<tt class="docutils literal">dispatch</tt> would become tedious and prone to error.  Python dictionaries,
introduced in the next section, provide a data type that will help us manage the
mapping between messages and operations.</p>
</div>
<div class="section" id="dictionaries">
<h3><a class="toc-backref" href="#id23">2.4.5&nbsp;&nbsp;&nbsp;Dictionaries</a></h3>
<p>Dictionaries are Python's built-in data type for storing and manipulating
correspondence relationships.  A dictionary contains key-value pairs, where both
the keys and values are objects.  The purpose of a dictionary is to provide an
abstraction for storing and retrieving values that are indexed not by
consecutive integers, but by descriptive keys.</p>
<p>Strings commonly serve as keys, because strings are our conventional
representation for names of things. This dictionary literal gives the values of
various Roman numerals.</p>
<pre class="doctest-block">&gt;&gt;&gt; numerals = {'I': 1.0, 'V': 5, 'X': 10}
</pre>
<p>Looking up values by their keys uses the element selection operator that we
previously applied to sequences.</p>
<pre class="doctest-block">&gt;&gt;&gt; numerals['X']
10
</pre>
<p>A dictionary can have at most one value for each key.  Adding new key-value
pairs and changing the existing value for a key can both be achieved with
assignment statements.</p>
<pre class="doctest-block">&gt;&gt;&gt; numerals['I'] = 1
&gt;&gt;&gt; numerals['L'] = 50
&gt;&gt;&gt; numerals
{'I': 1, 'X': 10, 'L': 50, 'V': 5}
</pre>
<p>Notice that <tt class="docutils literal">'L'</tt> was not added to the end of the output above.  Dictionaries
are unordered collections of key-value pairs.  When we print a dictionary, the
keys and values are rendered in some order, but as users of the language we
cannot predict what that order will be.</p>
<p>The dictionary abstraction also supports various methods of iterating of the
contents of the dictionary as a whole.  The methods <tt class="docutils literal">keys</tt>, <tt class="docutils literal">values</tt>, and
<tt class="docutils literal">items</tt> all return iterable values.</p>
<pre class="doctest-block">&gt;&gt;&gt; sum(numerals.values())
66
</pre>
<p>A list of key-value pairs can be converted into a dictionary by calling the
<tt class="docutils literal">dict</tt> constructor function.</p>
<pre class="doctest-block">&gt;&gt;&gt; dict([(3, 9), (4, 16), (5, 25)])
{3: 9, 4: 16, 5: 25}
</pre>
<p>Dictionaries do have some restrictions:</p>
<ul class="simple">
<li>A key of a dictionary cannot be an object of a mutable built-in type.</li>
<li>There can be at most one value for a given key.</li>
</ul>
<p>This first restriction is tied to the underlying implementation of dictionaries
in Python. The details of this implementation are not a topic of this course.
Intuitively, consider that the key tells Python where to find that key-value
pair in memory; if the key changes, the location of the pair may be lost.</p>
<p>The second restriction is a consequence of the dictionary abstraction, which is
designed to store and retrieve values for keys.  We can only retrieve <em>the</em>
value for a key if at most one such value exists in the dictionary.</p>
<p>A useful method implemented by dictionaries is <tt class="docutils literal">get</tt>, which returns either
the value for a key, if the key is present, or a default value.  The arguments
to <tt class="docutils literal">get</tt> are the key and the default value.</p>
<pre class="doctest-block">&gt;&gt;&gt; numerals.get('A', 0)
0
&gt;&gt;&gt; numerals.get('V', 0)
5
</pre>
<p>Dictionaries also have a comprehension syntax analogous to those of lists and
generator expressions.  Evaluating a dictionary comprehension yields a new
dictionary object.</p>
<pre class="doctest-block">&gt;&gt;&gt; {x: x*x for x in range(3,6)}
{3: 9, 4: 16, 5: 25}
</pre>
<p><strong>Implementation.</strong> We can implement an abstract data type that conforms to the
dictionary abstraction as a list of records, each of which is a two-element list
consisting of a key and the associated value.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_dict():
        """Return a functional implementation of a dictionary."""
        records = []
        def getitem(key):
            for k, v in records:
                if k == key:
                    return v
        def setitem(key, value):
            for item in records:
                if item[0] == key:
                    item[1] = value
                    return
            records.append([key, value])
        def dispatch(message, key=None, value=None):
            if message == 'getitem':
                return getitem(key)
            elif message == 'setitem':
                setitem(key, value)
            elif message == 'keys':
                return tuple(k for k, _ in records)
            elif message == 'values':
                return tuple(v for _, v in records)
        return dispatch
</pre>
<p>Again, we use the message passing method to organize our implementation.  We
have supported four messages: <tt class="docutils literal">getitem</tt>, <tt class="docutils literal">setitem</tt>, <tt class="docutils literal">keys</tt>, and
<tt class="docutils literal">values</tt>.  To look up a value for a key, we iterate through the records to
find a matching key.  To insert a value for a key, we iterate through the
records to see if there is already a record with that key. If not, we form a new
record. If there already is a record with this key, we set the value of the
record to the designated new value.</p>
<p>We can now use our implementation to store and retrieve values.</p>
<pre class="doctest-block">&gt;&gt;&gt; d = make_dict()
&gt;&gt;&gt; d('setitem', 3, 9)
&gt;&gt;&gt; d('setitem', 4, 16)
&gt;&gt;&gt; d('getitem', 3)
9
&gt;&gt;&gt; d('getitem', 4)
16
&gt;&gt;&gt; d('keys')
(3, 4)
&gt;&gt;&gt; d('values')
(9, 16)
</pre>
<p>This implementation of a dictionary is <em>not</em> optimized for fast record lookup,
because each response to the message <tt class="docutils literal">'getitem'</tt> must iterate through the
entire list of <tt class="docutils literal">records</tt>. The built-in dictionary type is considerably more
efficient.</p>
</div>
<div class="section" id="example-propagating-constraints">
<h3><a class="toc-backref" href="#id24">2.4.6&nbsp;&nbsp;&nbsp;Example: Propagating Constraints</a></h3>
<p>Mutable data allows us to simulate systems with change, but also allows us to
build new kinds of abstractions.  In this extended example, we combine nonlocal
assignment, lists, and dictionaries to build a <em>constraint-based system</em> that
supports computation in multiple directions. Expressing programs as constraints
is a type of <em>declarative programming</em>, in which a programmer declares the
structure of a problem to be solved, but abstracts away the details of exactly
how the solution to the problem is computed.</p>
<p>Computer programs are traditionally organized as one-directional computations,
which perform operations on pre-specified arguments to produce desired outputs.
On the other hand, we often want to model systems in terms of relations among
quantities. For example, we previously considered the ideal gas law, which
relates the pressure (<tt class="docutils literal">p</tt>), volume (<tt class="docutils literal">v</tt>), quantity (<tt class="docutils literal">n</tt>), and temperature
(<tt class="docutils literal">t</tt>) of an ideal gas via Boltzmann's constant (<tt class="docutils literal">k</tt>):</p>
<pre class="literal-block">p * v = n * k * t
</pre>
<p>Such an equation is not one-directional. Given any four of the quantities, we
can use this equation to compute the fifth. Yet translating the equation into a
traditional computer language would force us to choose one of the quantities to
be computed in terms of the other four. Thus, a function for computing the
pressure could not be used to compute the temperature, even though the
computations of both quantities arise from the same equation.</p>
<p>In this section, we sketch the design of a general model of linear
relationships.  We define primitive constraints that hold between quantities,
such as an <tt class="docutils literal">adder(a, b, c)</tt> constraint that enforces the mathematical
relationship <tt class="docutils literal">a + b = c</tt>.</p>
<p>We also define a means of combination, so that primitive constraints can be
combined to express more complex relations.  In this way, our program resembles
a programming language.  We combine constraints by constructing a network in
which constraints are joined by connectors. A connector is an object that
"holds" a value and may participate in one or more constraints.</p>
<p>For example, we know that the relationship between Fahrenheit and Celsius
temperatures is:</p>
<pre class="literal-block">9 * c = 5 * (f - 32)
</pre>
<p>This equation is a complex constraint between <tt class="docutils literal">c</tt> and <tt class="docutils literal">f</tt>. Such a constraint
can be thought of as a network consisting of primitive <tt class="docutils literal">adder</tt>,
<tt class="docutils literal">multiplier</tt>, and <tt class="docutils literal">constant</tt> constraints.</p>
<div class="figure">
<img alt="img/constraints.png" src="02_files/constraints.png">
</div>
<p>In this figure, we see on the left a multiplier box with three terminals,
labeled <tt class="docutils literal">a</tt>, <tt class="docutils literal">b</tt>, and <tt class="docutils literal">c</tt>. These connect the multiplier to the rest of the
network as follows: The <tt class="docutils literal">a</tt> terminal is linked to a connector <tt class="docutils literal">celsius</tt>, which
will hold the Celsius temperature. The <tt class="docutils literal">b</tt> terminal is linked to a connector
<tt class="docutils literal">w</tt>, which is also linked to a constant box that holds <tt class="docutils literal">9</tt>. The <tt class="docutils literal">c</tt>
terminal, which the multiplier box constrains to be the product of <tt class="docutils literal">a</tt> and
<tt class="docutils literal">b</tt>, is linked to the <tt class="docutils literal">c</tt> terminal of another multiplier box, whose <tt class="docutils literal">b</tt> is
connected to a constant <tt class="docutils literal">5</tt> and whose <tt class="docutils literal">a</tt> is connected to one of the terms
in the sum constraint.</p>
<p>Computation by such a network proceeds as follows: When a connector is given a
value (by the user or by a constraint box to which it is linked), it awakens all
of its associated constraints (except for the constraint that just awakened it)
to inform them that it has a value. Each awakened constraint box then polls its
connectors to see if there is enough information to determine a value for a
connector. If so, the box sets that connector, which then awakens all of its
associated constraints, and so on. For instance, in conversion between Celsius
and Fahrenheit, <tt class="docutils literal">w</tt>, <tt class="docutils literal">x</tt>, and <tt class="docutils literal">y</tt> are immediately set by the constant
boxes to <tt class="docutils literal">9</tt>, <tt class="docutils literal">5</tt>, and <tt class="docutils literal">32</tt>, respectively. The connectors awaken the
multipliers and the adder, which determine that there is not enough information
to proceed. If the user (or some other part of the network) sets the <tt class="docutils literal">celsius</tt>
connector to a value (say <tt class="docutils literal">25</tt>), the leftmost multiplier will be awakened, and
it will set <tt class="docutils literal">u</tt> to <tt class="docutils literal">25 * 9 = 225</tt>.  Then <tt class="docutils literal">u</tt> awakens the second
multiplier, which sets <tt class="docutils literal">v</tt> to <tt class="docutils literal">45</tt>, and <tt class="docutils literal">v</tt> awakens the adder, which sets
the <tt class="docutils literal">fahrenheit</tt> connector to <tt class="docutils literal">77</tt>.</p>
<p><strong>Using the Constraint System.</strong> To use the constraint system to carry out the
temperature computation outlined above, we first create two named connectors,
<tt class="docutils literal">celsius</tt> and <tt class="docutils literal">fahrenheit</tt>, by calling the <tt class="docutils literal">make_connector</tt> constructor.</p>
<pre class="doctest-block">&gt;&gt;&gt; celsius = make_connector('Celsius')
&gt;&gt;&gt; fahrenheit = make_connector('Fahrenheit')
</pre>
<p>Then, we link these connectors into a network that mirrors the figure above.
The function <tt class="docutils literal">make_converter</tt> assembles the various connectors and constraints
in the network.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_converter(c, f):
        """Connect c to f with constraints to convert from Celsius to Fahrenheit."""
        u, v, w, x, y = [make_connector() for _ in range(5)]
        multiplier(c, w, u)
        multiplier(v, x, u)
        adder(v, y, f)
        constant(w, 9)
        constant(x, 5)
        constant(y, 32)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; make_converter(celsius, fahrenheit)
</pre>
<p>We will use a message passing system to coordinate constraints and connectors.
Instead of using functions to answer messages, we will use dictionaries.  A
dispatch dictionary will have string-valued keys that denote the messages it
accepts.  The values associated with those keys will be the responses to those
messages.</p>
<p>Constraints are dictionaries that do not hold local states themselves. Their
responses to messages are non-pure functions that change the connectors that
they constrain.</p>
<p>Connectors are dictionaries that hold a current value and respond to messages
that manipulate that value.  Constraints will not change the value of connectors
directly, but instead will do so by sending messages, so that the connector can
notify other constraints in response to the change.  In this way, a connector
represents a number, but also encapsulates connector behavior.</p>
<p>One message we can send to a connector is to set its value.  Here, we (the
<tt class="docutils literal">'user'</tt>) set the value of <tt class="docutils literal">celsius</tt> to <tt class="docutils literal">25</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; celsius['set_val']('user', 25)
Celsius = 25
Fahrenheit = 77.0
</pre>
<p>Not only does the value of <tt class="docutils literal">celsius</tt> change to <tt class="docutils literal">25</tt>, but its value
propagates through the network, and so the value of <tt class="docutils literal">fahrenheit</tt> is changed as
well.  These changes are printed because we named these two connectors when we
constructed them.</p>
<p>Now we can try to set <tt class="docutils literal">fahrenheit</tt> to a new value, say <tt class="docutils literal">212</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; fahrenheit['set_val']('user', 212)
Contradiction detected: 77.0 vs 212
</pre>
<p>The connector complains that it has sensed a contradiction: Its value is
<tt class="docutils literal">77.0</tt>, and someone is trying to set it to <tt class="docutils literal">212</tt>. If we really want to reuse
the network with new values, we can tell <tt class="docutils literal">celsius</tt> to forget its old value:</p>
<pre class="doctest-block">&gt;&gt;&gt; celsius['forget']('user')
Celsius is forgotten
Fahrenheit is forgotten
</pre>
<p>The connector <tt class="docutils literal">celsius</tt> finds that the <tt class="docutils literal">user</tt>, who set its value originally,
is now retracting that value, so <tt class="docutils literal">celsius</tt> agrees to lose its value, and it
informs the rest of the network of this fact. This information eventually
propagates to <tt class="docutils literal">fahrenheit</tt>, which now finds that it has no reason for
continuing to believe that its own value is <tt class="docutils literal">77</tt>. Thus, it also gives up its
value.</p>
<p>Now that <tt class="docutils literal">fahrenheit</tt> has no value, we are free to set it to <tt class="docutils literal">212</tt>:</p>
<pre class="doctest-block">&gt;&gt;&gt; fahrenheit['set_val']('user', 212)
Fahrenheit = 212
Celsius = 100.0
</pre>
<p>This new value, when propagated through the network, forces <tt class="docutils literal">celsius</tt> to have
a value of <tt class="docutils literal">100</tt>. We have used the very same network to compute <tt class="docutils literal">celsius</tt>
given <tt class="docutils literal">fahrenheit</tt> and to compute <tt class="docutils literal">fahrenheit</tt> given <tt class="docutils literal">celsius</tt>. This
non-directionality of computation is the distinguishing feature of
constraint-based systems.</p>
<p><strong>Implementing the Constraint System.</strong> As we have seen, connectors are
dictionaries that map message names to function and data values.  We will
implement connectors that respond to the following messages:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">connector['set_val'](source,</span> value)</tt> indicates that the <tt class="docutils literal">source</tt> is
requesting the connector to set its current value to <tt class="docutils literal">value</tt>.</li>
<li><tt class="docutils literal"><span class="pre">connector['has_val']()</span></tt> returns whether the connector already has a value.</li>
<li><tt class="docutils literal"><span class="pre">connector['val']</span></tt> is the current value of the connector.</li>
<li><tt class="docutils literal"><span class="pre">connector['forget'](source)</span></tt> tells the connector that the <tt class="docutils literal">source</tt> is
requesting it to forget its value.</li>
<li><tt class="docutils literal"><span class="pre">connector['connect'](source)</span></tt> tells the connector to participate in a new
constraint, the <tt class="docutils literal">source</tt>.</li>
</ul>
<p>Constraints are also dictionaries, which receive information from connectors by
means of two messages:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">constraint['new_val']()</span></tt> indicates that some connector that is connected to
the constraint has a new value.</li>
<li><tt class="docutils literal"><span class="pre">constraint['forget']()</span></tt> indicates that some connector that is connected to
the constraint has forgotten its value.</li>
</ul>
<p>When constraints receive these messages, they propagate them appropriately to
other connectors.</p>
<p>The <tt class="docutils literal">adder</tt> function constructs an adder constraint over three connectors,
where the first two must add to the third: <tt class="docutils literal">a + b = c</tt>.  To support
multidirectional constraint propagation, the adder must also specify that it
subtracts <tt class="docutils literal">a</tt> from <tt class="docutils literal">c</tt> to get <tt class="docutils literal">b</tt> and likewise subtracts <tt class="docutils literal">b</tt> from <tt class="docutils literal">c</tt>
to get <tt class="docutils literal">a</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; from operator import add, sub
&gt;&gt;&gt; def adder(a, b, c):
        """The constraint that a + b = c."""
        return make_ternary_constraint(a, b, c, add, sub, sub)
</pre>
<p>We would like to implement a generic ternary (three-way) constraint, which
uses the three connectors and three functions from <tt class="docutils literal">adder</tt> to create a
constraint that accepts <tt class="docutils literal">new_val</tt> and <tt class="docutils literal">forget</tt> messages.  The response to
messages are local functions, which are placed in a dictionary called
<tt class="docutils literal">constraint</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_ternary_constraint(a, b, c, ab, ca, cb):
        """The constraint that ab(a,b)=c and ca(c,a)=b and cb(c,b) = a."""
        def new_value():
            av, bv, cv = [connector['has_val']() for connector in (a, b, c)]
            if av and bv:
                c['set_val'](constraint, ab(a['val'], b['val']))
            elif av and cv:
                b['set_val'](constraint, ca(c['val'], a['val']))
            elif bv and cv:
                a['set_val'](constraint, cb(c['val'], b['val']))
        def forget_value():
            for connector in (a, b, c):
                connector['forget'](constraint)
        constraint = {'new_val': new_value, 'forget': forget_value}
        for connector in (a, b, c):
            connector['connect'](constraint)
        return constraint
</pre>
<p>The dictionary called <tt class="docutils literal">constraint</tt> is a dispatch dictionary, but also the
constraint object itself. It responds to the two messages that constraints
receive, but is also passed as the <tt class="docutils literal">source</tt> argument in calls to its
connectors.</p>
<p>The constraint's local function <tt class="docutils literal">new_value</tt> is called whenever the constraint
is informed that one of its connectors has a value. This function first checks
to see if both <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> have values. If so, it tells <tt class="docutils literal">c</tt> to set its
value to the return value of function <tt class="docutils literal">ab</tt>, which is <tt class="docutils literal">add</tt> in the case of an
<tt class="docutils literal">adder</tt>. The constraint passes <em>itself</em> (<tt class="docutils literal">constraint</tt>) as the <tt class="docutils literal">source</tt>
argument of the connector, which is the adder object. If <tt class="docutils literal">a</tt> and <tt class="docutils literal">b</tt> do not
both have values, then the constraint checks <tt class="docutils literal">a</tt> and <tt class="docutils literal">c</tt>, and so on.</p>
<p>If the constraint is informed that one of its connectors has forgotten its
value, it requests that all of its connectors now forget their values. (Only
those values that were set by this constraint are actually lost.)</p>
<p>A <tt class="docutils literal">multiplier</tt> is very similar to an <tt class="docutils literal">adder</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; from operator import mul, truediv
&gt;&gt;&gt; def multiplier(a, b, c):
        """The constraint that a * b = c."""
        return make_ternary_constraint(a, b, c, mul, truediv, truediv)
</pre>
<p>A constant is a constraint as well, but one that is never sent any messages,
because it involves only a single connector that it sets on construction.</p>
<pre class="doctest-block">&gt;&gt;&gt; def constant(connector, value):
        """The constraint that connector = value."""
        constraint = {}
        connector['set_val'](constraint, value)
        return constraint
</pre>
<p>These three constraints are sufficient to implement our temperature conversion
network.</p>
<p><strong>Representing connectors.</strong> A connector is represented as a dictionary that
contains a value, but also has response functions with local state.  The
connector must track the <tt class="docutils literal">informant</tt> that gave it its current value, and a
list of <tt class="docutils literal">constraints</tt> in which it participates.</p>
<p>The constructor <tt class="docutils literal">make_connector</tt> has local functions for setting and
forgetting values, which are the responses to messages from constraints.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_connector(name=None):
        """A connector between constraints."""
        informant = None
        constraints = []
        def set_value(source, value):
            nonlocal informant
            val = connector['val']
            if val is None:
                informant, connector['val'] = source, value
                if name is not None:
                    print(name, '=', value)
                inform_all_except(source, 'new_val', constraints)
            else:
                if val != value:
                    print('Contradiction detected:', val, 'vs', value)
        def forget_value(source):
            nonlocal informant
            if informant == source:
                informant, connector['val'] = None, None
                if name is not None:
                    print(name, 'is forgotten')
                inform_all_except(source, 'forget', constraints)
        connector = {'val': None,
                     'set_val': set_value,
                     'forget': forget_value,
                     'has_val': lambda: connector['val'] is not None,
                     'connect': lambda source: constraints.append(source)}
        return connector
</pre>
<p>A connector is again a dispatch dictionary for the five messages used by
constraints to communicate with connectors. Four responses are functions, and
the final response is the value itself.</p>
<p>The local function <tt class="docutils literal">set_value</tt> is called when there is a request to set the
connector's value. If the connector does not currently have a value, it will set
its value and remember as <tt class="docutils literal">informant</tt> the source constraint that requested the
value to be set. Then the connector will notify all of its participating
constraints except the constraint that requested the value to be set. This is
accomplished using the following iterative function.</p>
<pre class="doctest-block">&gt;&gt;&gt; def inform_all_except(source, message, constraints):
        """Inform all constraints of the message, except source."""
        for c in constraints:
            if c != source:
                c[message]()
</pre>
<p>If a connector is asked to forget its value, it calls the local function
<tt class="docutils literal"><span class="pre">forget-value</span></tt>, which first checks to make sure that the request is coming
from the same constraint that set the value originally. If so, the connector
informs its associated constraints about the loss of the value.</p>
<p>The response to the message <tt class="docutils literal">has_val</tt> indicates whether the connector has a
value.  The response to the message <tt class="docutils literal">connect</tt> adds the source constraint to
the list of constraints.</p>
<p>The constraint program we have designed introduces many ideas that will appear
again in object-oriented programming.  Constraints and connectors are both
abstractions that are manipulated through messages.  When the value of a
connector is changed, it is changed via a message that not only changes the
value, but validates it (checking the source) and propagates its effects
(informing other constraints).  In fact, we will use a similar architecture of
dictionaries with string-valued keys and functional values to implement an
object-oriented system later in this chapter.</p>
</div>
</div>
<div class="section" id="object-oriented-programming">
<h2><a class="toc-backref" href="#id25">2.5&nbsp;&nbsp;&nbsp;Object-Oriented Programming</a></h2>
<p>Object-oriented programming (OOP) is a method for organizing programs that
brings together many of the ideas introduced in this chapter.  Like abstract
data types, objects create an abstraction barrier between the use and
implementation of data.  Like dispatch dictionaries in message passing, objects
respond to behavioral requests.  Like mutable data structures, objects have
local state that is not directly accessible from the global environment.
The Python object system provides new syntax to ease the task of implementing
all of these useful techniques for organizing programs.</p>
<p>But the object system offers more than just convenience; it enables a new
metaphor for designing programs in which several independent agents interact
within the computer. Each object bundles together local state and behavior in a
way that hides the complexity of both behind a data abstraction. Our example of
a constraint program began to develop this metaphor by passing messages between
constraints and connectors.  The Python object system extends this metaphor with
new ways to express how different parts of a program relate to and communicate
with each other.  Not only do objects pass messages, they also share behavior
among other objects of the same type and inherit characteristics from related
types.</p>
<p>The paradigm of object-oriented programming has its own vocabulary that
reinforces the object metaphor.  We have seen that an object is a data value
that has methods and attributes, accessible via dot notation. Every object also
has a type, called a <em>class</em>.  New classes can be defined in Python, just as new
functions can be defined.</p>
<div class="section" id="objects-and-classes">
<h3><a class="toc-backref" href="#id26">2.5.1&nbsp;&nbsp;&nbsp;Objects and Classes</a></h3>
<p>A class serves as a template for all objects whose type is that class. Every
object is an instance of some particular class.  The objects we have used so far
all have built-in classes, but new classes can be defined similarly to how new
functions can be defined.  A class definition specifies the attributes and
methods shared among objects of that class.  We will introduce the class
statement by revisiting the example of a bank account.</p>
<p>When introducing local state, we saw that bank accounts are naturally modeled as
mutable values that have a <tt class="docutils literal">balance</tt>.  A bank account object should have a
<tt class="docutils literal">withdraw</tt> method that updates the account balance and returns the requested
amount, if it is available.  We would like additional behavior to complete the
account abstraction: a bank account should be able to return its current
balance, return the name of the account holder, and accept deposits.</p>
<p>An <tt class="docutils literal">Account</tt> class allows us to create multiple instances of bank accounts.
The act of creating a new object instance is known as <em>instantiating</em> the class.
The syntax in Python for instantiating a class is identical to the syntax of
calling a function.  In this case, we call <tt class="docutils literal">Account</tt> with the argument
<tt class="docutils literal">'Jim'</tt>, the account holder's name.</p>
<pre class="doctest-block">&gt;&gt;&gt; a = Account('Jim')
</pre>
<p>An <em>attribute</em> of an object is a name-value pair associated with the object,
which is accessible via dot notation.  The attributes specific to a particular
object, as opposed to all objects of a class, are called <em>instance attributes</em>.
Each <tt class="docutils literal">Account</tt> has its own balance and account holder name, which are examples
of instance attributes. In the broader programming community, instance
attributes may also be called <em>fields</em>, <em>properties</em>, or <em>instance variables</em>.</p>
<pre class="doctest-block">&gt;&gt;&gt; a.holder
'Jim'
&gt;&gt;&gt; a.balance
0
</pre>
<p>Functions that operate on the object or perform object-specific computations are
called methods. The side effects and return value of a method can depend upon,
and change, other attributes of the object.  For example, <tt class="docutils literal">deposit</tt> is a
method of our <tt class="docutils literal">Account</tt> object <tt class="docutils literal">a</tt>. It takes one argument, the amount to
deposit, changes the <tt class="docutils literal">balance</tt> attribute of the object, and returns the
resulting balance.</p>
<pre class="doctest-block">&gt;&gt;&gt; a.deposit(15)
15
</pre>
<p>In OOP, we say that methods are <em>invoked</em> on a particular object.  As a result
of invoking the <tt class="docutils literal">withdraw</tt> method, either the withdrawal is approved and the
amount is deducted and returned, or the request is declined and the account
prints an error message.</p>
<pre class="doctest-block">&gt;&gt;&gt; a.withdraw(10)  # The withdraw method returns the balance after withdrawal
5
&gt;&gt;&gt; a.balance       # The balance attribute has changed
5
&gt;&gt;&gt; a.withdraw(10)
'Insufficient funds'
</pre>
<p>As illustrated above, the behavior of a method can depend upon the changing
attributes of the object.  Two calls to <tt class="docutils literal">withdraw</tt> with the same argument
return different results.</p>
</div>
<div class="section" id="defining-classes">
<h3><a class="toc-backref" href="#id27">2.5.2&nbsp;&nbsp;&nbsp;Defining Classes</a></h3>
<p>User-defined classes are created by <tt class="docutils literal">class</tt> statements, which consist of a
single clause.   A class statement defines the class name and a base class
(discussed in the section on Inheritance), then includes a suite of statements
to define the attributes of the class:</p>
<pre class="literal-block">class &lt;name&gt;(&lt;base class&gt;):
    &lt;suite&gt;
</pre>
<p>When a class statement is executed, a new class is created and bound to
<tt class="docutils literal">&lt;name&gt;</tt> in the first frame of the current environment.  The suite is then
executed.  Any names bound within the <tt class="docutils literal">&lt;suite&gt;</tt>  of a <tt class="docutils literal">class</tt> statement,
through <tt class="docutils literal">def</tt> or assignment statements, create or modify attributes of the
class.</p>
<p>Classes are typically organized around manipulating instance attributes, which
are the name-value pairs associated not with the class itself, but with each
object of that class.  The class specifies the instance attributes of its
objects by defining a method for initializing new objects.  For instance, part
of initializing an object of the <tt class="docutils literal">Account</tt> class is to assign it a starting
balance of 0.</p>
<p>The <tt class="docutils literal">&lt;suite&gt;</tt> of a <tt class="docutils literal">class</tt> statement contains <tt class="docutils literal">def</tt> statements that define
new methods for objects of that class.  The method that initializes objects has
a special name in Python, <tt class="docutils literal">__init__</tt> (two underscores on each side of
"init"), and is called the <em>constructor</em> for the class.</p>
<pre class="doctest-block">&gt;&gt;&gt; class Account(object):
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
</pre>
<p>The <tt class="docutils literal">__init__</tt> method for <tt class="docutils literal">Account</tt> has two formal parameters.  The first
one, <tt class="docutils literal">self</tt>, is bound to the newly created <tt class="docutils literal">Account</tt> object. The second
parameter, <tt class="docutils literal">account_holder</tt>, is bound to the argument passed to the class when
it is called to be instantiated.</p>
<p>The constructor binds the instance attribute name <tt class="docutils literal">balance</tt> to <tt class="docutils literal">0</tt>.  It also
binds the attribute name <tt class="docutils literal">holder</tt> to the value of the name <tt class="docutils literal">account_holder</tt>.
The formal parameter <tt class="docutils literal">account_holder</tt> is a local name to the <tt class="docutils literal">__init__</tt>
method.  On the other hand, the name <tt class="docutils literal">holder</tt> that is bound via the final
assignment statement persists, because it is stored as an attribute of <tt class="docutils literal">self</tt>
using dot notation.</p>
<p>Having defined the <tt class="docutils literal">Account</tt> class, we can instantiate it.</p>
<pre class="doctest-block">&gt;&gt;&gt; a = Account('Jim')
</pre>
<p>This "call" to the <tt class="docutils literal">Account</tt> class creates a new object that is an instance of
<tt class="docutils literal">Account</tt>, then calls the constructor function <tt class="docutils literal">__init__</tt> with two
arguments: the newly created object and the string <tt class="docutils literal">'Jim'</tt>.  By convention, we
use the parameter name <tt class="docutils literal">self</tt> for the first argument of a constructor, because
it is bound to the object being instantiated.  This convention is adopted in
virtually all Python code.</p>
<p>Now, we can access the object's <tt class="docutils literal">balance</tt> and <tt class="docutils literal">holder</tt> using dot notation.</p>
<pre class="doctest-block">&gt;&gt;&gt; a.balance
0
&gt;&gt;&gt; a.holder
'Jim'
</pre>
<p><strong>Identity.</strong> Each new account instance has its own balance attribute, the value
of which is independent of other objects of the same class.</p>
<pre class="doctest-block">&gt;&gt;&gt; b = Account('Jack')
&gt;&gt;&gt; b.balance = 200
&gt;&gt;&gt; [acc.balance for acc in (a, b)]
[0, 200]
</pre>
<p>To enforce this separation, every object that is an instance of a user-defined
class has a unique identity.  Object identity is compared using the <tt class="docutils literal">is</tt> and
<tt class="docutils literal">is not</tt> operators.</p>
<pre class="doctest-block">&gt;&gt;&gt; a is a
True
&gt;&gt;&gt; a is not b
True
</pre>
<p>Despite being constructed from identical calls, the objects bound to <tt class="docutils literal">a</tt> and
<tt class="docutils literal">b</tt> are not the same.  As usual, binding an object to a new name using
assignment does not create a new object.</p>
<pre class="doctest-block">&gt;&gt;&gt; c = a
&gt;&gt;&gt; c is a
True
</pre>
<p>New objects that have user-defined classes are only created when a class (such
as <tt class="docutils literal">Account</tt>) is instantiated with call expression syntax.</p>
<p><strong>Methods.</strong> Object methods are also defined by a <tt class="docutils literal">def</tt> statement in the suite
of a <tt class="docutils literal">class</tt> statement.  Below, <tt class="docutils literal">deposit</tt> and <tt class="docutils literal">withdraw</tt> are both defined
as methods on objects of the <tt class="docutils literal">Account</tt> class.</p>
<pre class="doctest-block">&gt;&gt;&gt; class Account(object):
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
        def deposit(self, amount):
            self.balance = self.balance + amount
            return self.balance
        def withdraw(self, amount):
            if amount &gt; self.balance:
                return 'Insufficient funds'
            self.balance = self.balance - amount
            return self.balance
</pre>
<p>While method definitions do not differ from function definitions in how they are
declared, method definitions do have a different effect.  The function value
that is created by a <tt class="docutils literal">def</tt> statement within a <tt class="docutils literal">class</tt> statement is bound to
the declared name, but bound locally within the class as an attribute.  That
value is invoked as a method using dot notation from an instance of the class.</p>
<p>Each method definition again includes a special first parameter <tt class="docutils literal">self</tt>,
which is bound to the object on which the method is invoked.  For example,
let us say that <tt class="docutils literal">deposit</tt> is invoked on a particular <tt class="docutils literal">Account</tt> object and
passed a single argument value: the amount deposited.  The object itself is
bound to <tt class="docutils literal">self</tt>, while the argument is bound to <tt class="docutils literal">amount</tt>.  All invoked
methods have access to the object via the <tt class="docutils literal">self</tt> parameter, and so they can
all access and manipulate the object's state.</p>
<p>To invoke these methods, we again use dot notation, as illustrated below.</p>
<pre class="doctest-block">&gt;&gt;&gt; tom_account = Account('Tom')
&gt;&gt;&gt; tom_account.deposit(100)
100
&gt;&gt;&gt; tom_account.withdraw(90)
10
&gt;&gt;&gt; tom_account.withdraw(90)
'Insufficient funds'
&gt;&gt;&gt; tom_account.holder
'Tom'
</pre>
<p>When a method is invoked via dot notation, the object itself (bound to
<tt class="docutils literal">tom_account</tt>, in this case) plays a dual role.  First, it determines what the
name <tt class="docutils literal">withdraw</tt> means; <tt class="docutils literal">withdraw</tt> is not a name in the environment, but
instead a name that is local to the <tt class="docutils literal">Account</tt> class.  Second, it is bound to
the first parameter <tt class="docutils literal">self</tt> when the <tt class="docutils literal">withdraw</tt> method is invoked.  The
details of the procedure for evaluating dot notation follow in the next
section.</p>
</div>
<div class="section" id="message-passing-and-dot-expressions">
<h3><a class="toc-backref" href="#id28">2.5.3&nbsp;&nbsp;&nbsp;Message Passing and Dot Expressions</a></h3>
<p>Methods, which are defined in classes, and instance attributes, which are
typically assigned in constructors, are the fundamental elements of
object-oriented programming.  These two concepts replicate much of the
behavior of a dispatch dictionary in a message passing implementation of a data
value.  Objects take messages using dot notation, but instead of those messages
being arbitrary string-valued keys, they are names local to a class.  Objects
also have named local state values (the instance attributes), but that state can
be accessed and manipulated using dot notation, without having to employ
<tt class="docutils literal">nonlocal</tt> statements in the implementation.</p>
<p>The central idea in message passing was that data values should have behavior by
responding to messages that are relevant to the abstract type they represent.
Dot notation is a syntactic feature of Python that formalizes the message
passing metaphor. The advantage of using a language with a built-in object system
is that message passing can interact seamlessly with other language features,
such as assignment statements.  We do not require different messages to "get"
or "set" the value associated with a local attribute name; the language syntax
allows us to use the message name directly.</p>
<p><strong>Dot expressions.</strong>
The code fragment <tt class="docutils literal">tom_account.deposit</tt> is called a <em>dot expression</em>. A dot
expression consists of an expression, a dot, and a name:</p>
<pre class="literal-block">&lt;expression&gt; . &lt;name&gt;
</pre>
<p>The <tt class="docutils literal">&lt;expression&gt;</tt> can be any valid Python expression, but the <tt class="docutils literal">&lt;name&gt;</tt> must
be a simple name (not an expression that evaluates to a name).  A dot expression
evaluates to the value of the attribute with the given <tt class="docutils literal">&lt;name&gt;</tt>, for the
object that is the value of the <tt class="docutils literal">&lt;expression&gt;</tt>.</p>
<p>The built-in function <tt class="docutils literal">getattr</tt> also returns an attribute for an object by
name.  It is the function equivalent of dot notation.  Using <tt class="docutils literal">getattr</tt>, we can
look up an attribute using a string, just as we did with a dispatch dictionary.</p>
<pre class="doctest-block">&gt;&gt;&gt; getattr(tom_account, 'balance')
10
</pre>
<p>We can also test whether an object has a named attribute with <tt class="docutils literal">hasattr</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; hasattr(tom_account, 'deposit')
True
</pre>
<p>The attributes of an object include all of its instance attributes, along with
all of the attributes (including methods) defined in its class.  Methods are
attributes of the class that require special handling.</p>
<p><strong>Method and functions.</strong> When a method is invoked on an object, that object is
implicitly passed as the first argument to the method. That is, the object that
is the value of the <tt class="docutils literal">&lt;expression&gt;</tt> to the left of the dot is passed
automatically as the first argument to the method named on the right side of the
dot expression.  As a result, the object is bound to the parameter <tt class="docutils literal">self</tt>.</p>
<p>To achieve automatic <tt class="docutils literal">self</tt> binding, Python distinguishes between
<em>functions</em>, which we have been creating since the beginning of the course, and
<em>bound methods</em>, which couple together a function and the object on which
that method will be invoked. A bound method value is already associated with its
first argument, the instance on which it was invoked, which will be named
<tt class="docutils literal">self</tt> when the method is called.</p>
<p>We can see the difference in the interactive interpreter by calling <tt class="docutils literal">type</tt> on
the returned values of dot expressions.  As an attribute of a class, a method
is just a function, but as an attribute of an instance, it is a bound method:</p>
<pre class="doctest-block">&gt;&gt;&gt; type(Account.deposit)
&lt;class 'function'&gt;
&gt;&gt;&gt; type(tom_account.deposit)
&lt;class 'method'&gt;
</pre>
<p>These two results differ only in the fact that the first is a standard
two-argument function with parameters <tt class="docutils literal">self</tt> and <tt class="docutils literal">amount</tt>. The second
is a one-argument method, where the name <tt class="docutils literal">self</tt> will be bound to the object
named <tt class="docutils literal">tom_account</tt> automatically when the method is called, while the
parameter <tt class="docutils literal">amount</tt> will be bound to the argument passed to the method. Both of
these values, whether function values or bound method values, are associated
with the same <tt class="docutils literal">deposit</tt> function body.</p>
<p>We can call <tt class="docutils literal">deposit</tt> in two ways: as a function and as a bound method.  In
the former case, we must supply an argument for the <tt class="docutils literal">self</tt> parameter
explicitly.  In the latter case, the <tt class="docutils literal">self</tt> parameter is bound automatically.</p>
<pre class="doctest-block">&gt;&gt;&gt; Account.deposit(tom_account, 1001)  # The deposit function requires 2 arguments
1011
&gt;&gt;&gt; tom_account.deposit(1000)           # The deposit method takes 1 argument
2011
</pre>
<p>The function <tt class="docutils literal">getattr</tt> behaves exactly like dot notation: if its first
argument is an object but the name is a method defined in the class, then
<tt class="docutils literal">getattr</tt> returns a bound method value.  On the other hand, if the first
argument is a class, then <tt class="docutils literal">getattr</tt> returns the attribute value directly,
which is a plain function.</p>
<p><strong>Practical guidance: naming conventions.</strong> Class names are conventionally
written using the CapWords convention (also called CamelCase because the capital
letters in the middle of a name are like humps).  Method names follow the
standard convention of naming functions using lowercased words separated by
underscores.</p>
<p>In some cases, there are instance variables and methods that are related to the
maintenance and consistency of an object that we don't want users of the object
to see or use.  They are not part of the abstraction defined by a class, but
instead part of the implementation.  Python's convention dictates that if an
attribute name starts with an underscore, it should only be accessed within
methods of the class itself, rather than by users of the class.</p>
</div>
<div class="section" id="class-attributes">
<h3><a class="toc-backref" href="#id29">2.5.4&nbsp;&nbsp;&nbsp;Class Attributes</a></h3>
<p>Some attribute values are shared across all objects of a given class. Such
attributes are associated with the class itself, rather than any individual
instance of the class. For instance, let us say that a bank pays interest on the
balance of accounts at a fixed interest rate. That interest rate may change, but
it is a single value shared across all accounts.</p>
<p>Class attributes are created by assignment statements in the suite of a
<tt class="docutils literal">class</tt> statement, outside of any method definition. In the broader developer
community, class attributes may also be called class variables or static
variables. The following class statement creates a class attribute for
<tt class="docutils literal">Account</tt> with the name <tt class="docutils literal">interest</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; class Account(object):
        interest = 0.02            # A class attribute
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
        # Additional methods would be defined here
</pre>
<p>This attribute can still be accessed from any instance of the class.</p>
<pre class="doctest-block">&gt;&gt;&gt; tom_account = Account('Tom')
&gt;&gt;&gt; jim_account = Account('Jim')
&gt;&gt;&gt; tom_account.interest
0.02
&gt;&gt;&gt; jim_account.interest
0.02
</pre>
<p>However, a single assignment statement to a class attribute changes the value of
the attribute for all instances of the class.</p>
<pre class="doctest-block">&gt;&gt;&gt; Account.interest = 0.04
&gt;&gt;&gt; tom_account.interest
0.04
&gt;&gt;&gt; jim_account.interest
0.04
</pre>
<p><strong>Attribute names.</strong> We have introduced enough complexity into our object system
that we have to specify how names are resolved to particular attributes.  After
all, we could easily have a class attribute and an instance attribute with the
same name.</p>
<p>As we have seen, a dot expressions consist of an expression, a dot, and a name:</p>
<pre class="literal-block">&lt;expression&gt; . &lt;name&gt;
</pre>
<p>To evaluate a dot expression:</p>
<ol class="arabic simple">
<li>Evaluate the <tt class="docutils literal">&lt;expression&gt;</tt> to the left of the dot, which yields the
<em>object</em> of the dot expression.</li>
<li><tt class="docutils literal">&lt;name&gt;</tt> is matched against the instance attributes of that object; if an
attribute with that name exists, its value is returned.</li>
<li>If <tt class="docutils literal">&lt;name&gt;</tt> does not appear among instance attributes, then <tt class="docutils literal">&lt;name&gt;</tt> is
looked up in the class, which yields a class attribute value.</li>
<li>That value is returned unless it is a function, in which case a bound method
is returned instead.</li>
</ol>
<p>In this evaluation procedure, instance attributes are found before class
attributes, just as local names have priority over global in an environment.
Methods defined within the class are bound to the object of the dot expression
during the third step of this evaluation procedure.  The procedure for looking
up a name in a class has additional nuances that will arise shortly, once we
introduce class inheritance.</p>
<p><strong>Assignment.</strong> All assignment statements that contain a dot expression on their
left-hand side affect attributes for the object of that dot expression.  If the
object is an instance, then assignment sets an instance attribute.  If the
object is a class, then assignment sets a class attribute.  As a consequence of
this rule, assignment to an attribute of an object cannot affect the attributes
of its class.  The examples below illustrate this distinction.</p>
<p>If we assign to the named attribute <tt class="docutils literal">interest</tt> of an account instance, we
create a new instance attribute that has the same name as the existing class
attribute.</p>
<pre class="doctest-block">&gt;&gt;&gt; jim_account.interest = 0.08
</pre>
<p>and that attribute value will be returned from a dot expression.</p>
<pre class="doctest-block">&gt;&gt;&gt; jim_account.interest
0.08
</pre>
<p>However, the class attribute <tt class="docutils literal">interest</tt> still retains its original value,
which is returned for all other accounts.</p>
<pre class="doctest-block">&gt;&gt;&gt; tom_account.interest
0.04
</pre>
<p>Changes to the class attribute <tt class="docutils literal">interest</tt> will affect <tt class="docutils literal">tom_account</tt>, but the
instance attribute for <tt class="docutils literal">jim_account</tt> will be unaffected.</p>
<pre class="doctest-block">&gt;&gt;&gt; Account.interest = 0.05  # changing the class attribute
&gt;&gt;&gt; tom_account.interest     # changes instances without like-named instance attributes
0.05
&gt;&gt;&gt; jim_account.interest     # but the existing instance attribute is unaffected
0.08
</pre>
</div>
<div class="section" id="inheritance">
<h3><a class="toc-backref" href="#id30">2.5.5&nbsp;&nbsp;&nbsp;Inheritance</a></h3>
<p>When working in the OOP paradigm, we often find that different abstract data
types are related.  In particular, we find that similar classes differ in their
amount of specialization. Two classes may have similar attributes, but one
represents a special case of the other.</p>
<p>For example, we may want to implement a checking account, which is different
from a standard account. A checking account charges an extra $1 for each
withdrawal and has a lower interest rate.  Here, we demonstrate the desired
behavior.</p>
<pre class="doctest-block">&gt;&gt;&gt; ch = CheckingAccount('Tom')
&gt;&gt;&gt; ch.interest     # Lower interest rate for checking accounts
0.01
&gt;&gt;&gt; ch.deposit(20)  # Deposits are the same
20
&gt;&gt;&gt; ch.withdraw(5)  # withdrawals decrease balance by an extra charge
14
</pre>
<p>A <tt class="docutils literal">CheckingAccount</tt> is a specialization of an <tt class="docutils literal">Account</tt>.  In OOP
terminology, the generic account will serve as the base class of
<tt class="docutils literal">CheckingAccount</tt>, while <tt class="docutils literal">CheckingAccount</tt> will be a subclass of
<tt class="docutils literal">Account</tt>.  (The terms <em>parent class</em> and <em>superclass</em> are also used for the
base class, while <em>child class</em> is also used for the subclass.)</p>
<p>A subclass <em>inherits</em> the attributes of its base class, but may <em>override</em>
certain attributes, including certain methods. With inheritance, we only specify
what is different between the subclass and the base class. Anything that we
leave unspecified in the subclass is automatically assumed to behave just as it
would for the base class.</p>
<p>Inheritance also has a role in our object metaphor, in addition to being a
useful organizational feature.  Inheritance is meant to represent <em>is-a</em>
relationships between classes, which contrast with <em>has-a</em> relationships.  A
checking account <em>is-a</em> specific type of account, so having a
<tt class="docutils literal">CheckingAccount</tt> inherit from <tt class="docutils literal">Account</tt> is an appropriate use of
inheritance. On the other hand, a bank <em>has-a</em> list of bank accounts that it
manages, so neither should inherit from the other.  Instead, a list of account
objects would be naturally expressed as an instance attribute of a bank object.</p>
</div>
<div class="section" id="using-inheritance">
<h3><a class="toc-backref" href="#id31">2.5.6&nbsp;&nbsp;&nbsp;Using Inheritance</a></h3>
<p>We specify inheritance by putting the base class in parentheses after the
class name. First, we give a full implementation of the <tt class="docutils literal">Account</tt> class, which
includes docstrings for the class and its methods.</p>
<pre class="doctest-block">&gt;&gt;&gt; class Account(object):
        """A bank account that has a non-negative balance."""
        interest = 0.02
        def __init__(self, account_holder):
            self.balance = 0
            self.holder = account_holder
        def deposit(self, amount):
            """Increase the account balance by amount and return the new balance."""
            self.balance = self.balance + amount
            return self.balance
        def withdraw(self, amount):
            """Decrease the account balance by amount and return the new balance."""
            if amount &gt; self.balance:
                return 'Insufficient funds'
            self.balance = self.balance - amount
            return self.balance
</pre>
<p>A full implementation of <tt class="docutils literal">CheckingAccount</tt> appears below.</p>
<pre class="doctest-block">&gt;&gt;&gt; class CheckingAccount(Account):
        """A bank account that charges for withdrawals."""
        withdraw_charge = 1
        interest = 0.01
        def withdraw(self, amount):
            return Account.withdraw(self, amount + self.withdraw_charge)
</pre>
<p>Here, we introduce a class attribute <tt class="docutils literal">withdraw_charge</tt> that is specific to the
<tt class="docutils literal">CheckingAccount</tt> class. We assign a lower value to the <tt class="docutils literal">interest</tt>
attribute.  We also define a new <tt class="docutils literal">withdraw</tt> method to override the behavior
defined in the <tt class="docutils literal">Account</tt> class. With no further statements in the class suite,
all other behavior is inherited from the base class <tt class="docutils literal">Account</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; checking = CheckingAccount('Sam')
&gt;&gt;&gt; checking.deposit(10)
10
&gt;&gt;&gt; checking.withdraw(5)
4
&gt;&gt;&gt; checking.interest
0.01
</pre>
<p>The expression <tt class="docutils literal">checking.deposit</tt> evaluates to a bound method for making
deposits, which was defined in the <tt class="docutils literal">Account</tt> class. When Python
resolves a name in a dot expression that is not an attribute of the instance, it
looks up the name in the class.  In fact, the act of "looking up" a name in a
class tries to find that name in every base class in the inheritance chain for
the original object's class.  We can define this procedure recursively.  To look
up a name in a class.</p>
<ol class="arabic simple">
<li>If it names an attribute in the class, return the attribute value.</li>
<li>Otherwise, look up the name in the base class, if there is one.</li>
</ol>
<p>In the case of <tt class="docutils literal">deposit</tt>, Python would have looked for the name first on the
instance, and then in the <tt class="docutils literal">CheckingAccount</tt> class.  Finally, it would look in
the <tt class="docutils literal">Account</tt> class, where <tt class="docutils literal">deposit</tt> is defined. According to our evaluation
rule for dot expressions, since <tt class="docutils literal">deposit</tt> is a function looked up in the class
for the <tt class="docutils literal">checking</tt> instance, the dot expression evaluates to a bound method
value.  That method is invoked with the argument <tt class="docutils literal">10</tt>, which calls the deposit
method with <tt class="docutils literal">self</tt> bound to the <tt class="docutils literal">checking</tt> object and <tt class="docutils literal">amount</tt> bound to
<tt class="docutils literal">10</tt>.</p>
<p>The class of an object stays constant throughout.  Even though the <tt class="docutils literal">deposit</tt>
method was found in the <tt class="docutils literal">Account</tt> class, <tt class="docutils literal">deposit</tt> is called with <tt class="docutils literal">self</tt>
bound to an instance of <tt class="docutils literal">CheckingAccount</tt>, not of <tt class="docutils literal">Account</tt>.</p>
<p><strong>Calling ancestors.</strong> Attributes that have been overridden are still
accessible via class objects.  For instance, we implemented
the <tt class="docutils literal">withdraw</tt> method of <tt class="docutils literal">CheckingAccount</tt> by calling the <tt class="docutils literal">withdraw</tt>
method of <tt class="docutils literal">Account</tt> with an argument that included the <tt class="docutils literal">withdraw_charge</tt>.</p>
<p>Notice that we called <tt class="docutils literal">self.withdraw_charge</tt> rather than the equivalent
<tt class="docutils literal">CheckingAccount.withdraw_charge</tt>.  The benefit of the former over the latter
is that a class that inherits from <tt class="docutils literal">CheckingAccount</tt> might override the
withdrawal charge.  If that is the case, we would like our implementation of
<tt class="docutils literal">withdraw</tt> to find that new value instead of the old one.</p>
</div>
<div class="section" id="multiple-inheritance">
<h3><a class="toc-backref" href="#id32">2.5.7&nbsp;&nbsp;&nbsp;Multiple Inheritance</a></h3>
<p>Python supports the concept of a subclass inheriting attributes from multiple
base classes, a language feature called <em>multiple inheritance</em>.</p>
<p>Suppose that we have a <tt class="docutils literal">SavingsAccount</tt> that inherits from <tt class="docutils literal">Account</tt>, but
charges customers a small fee every time they make a deposit.</p>
<pre class="doctest-block">&gt;&gt;&gt; class SavingsAccount(Account):
        deposit_charge = 2
        def deposit(self, amount):
            return Account.deposit(self, amount - self.deposit_charge)
</pre>
<p>Then, a clever executive conceives of an <tt class="docutils literal">AsSeenOnTVAccount</tt> account with the
best features of both <tt class="docutils literal">CheckingAccount</tt> and <tt class="docutils literal">SavingsAccount</tt>: withdrawal
fees, deposit fees, and a low interest rate. It's both a checking and a savings
account in one! "If we build it," the executive reasons, "someone will sign up
and pay all those fees.  We'll even give them a dollar."</p>
<pre class="doctest-block">&gt;&gt;&gt; class AsSeenOnTVAccount(CheckingAccount, SavingsAccount):
        def __init__(self, account_holder):
            self.holder = account_holder
            self.balance = 1           # A free dollar!
</pre>
<p>In fact, this implementation is complete.  Both withdrawal and deposits will
generate fees, using the function definitions in <tt class="docutils literal">CheckingAccount</tt> and
<tt class="docutils literal">SavingsAccount</tt> respectively.</p>
<pre class="doctest-block">&gt;&gt;&gt; such_a_deal = AsSeenOnTVAccount("John")
&gt;&gt;&gt; such_a_deal.balance
1
&gt;&gt;&gt; such_a_deal.deposit(20)            # $2 fee from SavingsAccount.deposit
19
&gt;&gt;&gt; such_a_deal.withdraw(5)            # $1 fee from CheckingAccount.withdraw
13
</pre>
<p>Non-ambiguous references are resolved correctly as expected:</p>
<pre class="doctest-block">&gt;&gt;&gt; such_a_deal.deposit_charge
2
&gt;&gt;&gt; such_a_deal.withdraw_charge
1
</pre>
<p>But what about when the reference is ambiguous, such as the reference to the
<tt class="docutils literal">withdraw</tt> method that is defined in both <tt class="docutils literal">Account</tt> and <tt class="docutils literal">CheckingAccount</tt>?
The figure below depicts an <em>inheritance graph</em> for the <tt class="docutils literal">AsSeenOnTVAccount</tt>
class.  Each arrow points from a subclass to a base class.</p>
<div class="figure">
<img alt="img/multiple_inheritance.png" src="02_files/multiple_inheritance.png">
</div>
<p>For a simple "diamond" shape like this, Python resolves names from left to
right, then upwards.  In this example, Python checks for an attribute name in
the following classes, in order, until an attribute with that name is found:</p>
<pre class="literal-block">AsSeenOnTVAccount, CheckingAccount, SavingsAccount, Account, object
</pre>
<p>There is no correct solution to the inheritance ordering problem, as there are
cases in which we might prefer to give precedence to certain inherited classes
over others.  However, any programming language that supports multiple
inheritance must select some ordering in a consistent way, so that users of the
language can predict the behavior of their programs.</p>
<p><strong>Further reading.</strong> Python resolves this name using a recursive algorithm
called the C3 Method Resolution Ordering.  The method resolution order of any
class can be queried using the <tt class="docutils literal">mro</tt> method on all classes.</p>
<pre class="doctest-block">&gt;&gt;&gt; [c.__name__ for c in AsSeenOnTVAccount.mro()]
['AsSeenOnTVAccount', 'CheckingAccount', 'SavingsAccount', 'Account', 'object']
</pre>
<p>The precise algorithm for finding method resolution orderings is not a topic for
this course, but is <a class="reference external" href="http://python-history.blogspot.com/2010/06/method-resolution-order.html">described by Python's primary author</a> with
a reference to the original paper.</p>
</div>
<div class="section" id="the-role-of-objects">
<h3><a class="toc-backref" href="#id33">2.5.8&nbsp;&nbsp;&nbsp;The Role of Objects</a></h3>
<p>The Python object system is designed to make data abstraction and message
passing both convenient and flexible.  The specialized syntax of classes,
methods, inheritance, and dot expressions all enable us to formalize the object
metaphor in our programs, which improves our ability to organize large programs.</p>
<p>In particular, we would like our object system to promote a <em>separation of
concerns</em> among the different aspects of the program.  Each object in a program
encapsulates and manages some part of the program's state, and each class
statement defines the functions that implement some part of the program's
overall logic.  Abstraction barriers enforce the boundaries between different
aspects of a large program.</p>
<p>Object-oriented programming is particularly well-suited to programs that model
systems that have separate but interacting parts.  For instance, different users
interact in a social network, different characters interact in a game, and
different shapes interact in a physical simulation. When representing such
systems, the objects in a program often map naturally onto objects in the system
being modeled, and classes represent their types and relationships.</p>
<p>On the other hand, classes may not provide the best mechanism for implementing
certain abstractions.  Functional abstractions provide a more natural metaphor
for representing relationships between inputs and outputs. One should not feel
compelled to fit every bit of logic in a program within a class, especially when
defining independent functions for manipulating data is more natural.  Functions
can also enforce a separation of concerns.</p>
<p>Multi-paradigm languages like Python allow programmers to match organizational
paradigms to appropriate problems. Learning to identify when to introduce a new
class, as opposed to a new function, in order to simplify or modularize a
program, is an important design skill in software engineering that deserves
careful attention.</p>
</div>
</div>
<div class="section" id="implementing-classes-and-objects">
<h2><a class="toc-backref" href="#id34">2.6&nbsp;&nbsp;&nbsp;Implementing Classes and Objects</a></h2>
<p>When working in the object-oriented programming paradigm, we use the object
metaphor to guide the organization of our programs.  Most logic about how to
represent and manipulate data is expressed within class declarations.  In this
section, we see that classes and objects can themselves be represented using
just functions and dictionaries.  The purpose of implementing an object system
in this way is to illustrate that using the object metaphor does not require a
special programming language.  Programs can be object-oriented, even in
programming languages that do not have a built-in object system.</p>
<p>In order to implement objects, we will abandon dot notation (which does require
built-in language support), but create dispatch dictionaries that behave
in much the same way as the elements of the built-in object system. We have
already seen how to implement message-passing behavior through dispatch
dictionaries.  To implement an object system in full, we send messages between
instances, classes, and base classes, all of which are dictionaries that contain
attributes.</p>
<p>We will not implement the entire Python object system, which includes features
that we have not covered in this text (e.g., meta-classes and static methods).
We will focus instead on user-defined classes without multiple inheritance and
without introspective behavior (such as returning the class of an instance).
Our implementation is not meant to follow the precise specification of the
Python type system.  Instead, it is designed to implement the core functionality
that enables the object metaphor.</p>
<div class="section" id="instances">
<h3><a class="toc-backref" href="#id35">2.6.1&nbsp;&nbsp;&nbsp;Instances</a></h3>
<p>We begin with instances.  An instance has named attributes, such as the balance
of an account, which can be set and retrieved. We implement an instance using a
dispatch dictionary that responds to messages that "get" and "set" attribute
values.  Attributes themselves are stored in a local dictionary called
<tt class="docutils literal">attributes</tt>.</p>
<p>As we have seen previously in this chapter, dictionaries themselves are abstract
data types.  We implemented dictionaries with lists, we implemented lists with
pairs, and we implemented pairs with functions. As we implement an object system
in terms of dictionaries, keep in mind that we could just as well be
implementing objects using functions alone.</p>
<p>To begin our implementation, we assume that we have a class implementation
that can look up any names that are not part of the instance.  We pass in a
class to <tt class="docutils literal">make_instance</tt> as the parameter <tt class="docutils literal">cls</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_instance(cls):
        """Return a new object instance, which is a dispatch dictionary."""
        def get_value(name):
            if name in attributes:
                return attributes[name]
            else:
                value = cls['get'](name)
                return bind_method(value, instance)
        def set_value(name, value):
            attributes[name] = value
        attributes = {}
        instance = {'get': get_value, 'set': set_value}
        return instance
</pre>
<p>The <tt class="docutils literal">instance</tt> is a dispatch dictionary that responds to the messages <tt class="docutils literal">get</tt>
and <tt class="docutils literal">set</tt>.  The <tt class="docutils literal">set</tt> message corresponds to attribute assignment in
Python's object system: all assigned attributes are stored directly within the
object's local attribute dictionary.  In <tt class="docutils literal">get</tt>, if <tt class="docutils literal">name</tt> does not appear in
the local <tt class="docutils literal">attributes</tt> dictionary, then it is looked up in the class. If the
<tt class="docutils literal">value</tt> returned by <tt class="docutils literal">cls</tt> is a function, it must be bound to the instance.</p>
<p><strong>Bound method values.</strong>  The <tt class="docutils literal">get_value</tt> function in <tt class="docutils literal">make_instance</tt> finds
a named attribute in its class with <tt class="docutils literal">get</tt>, then calls <tt class="docutils literal">bind_method</tt>.
Binding a method only applies to function values, and it creates a bound method
value from a function value by inserting the instance as the first argument:</p>
<pre class="doctest-block">&gt;&gt;&gt; def bind_method(value, instance):
        """Return a bound method if value is callable, or value otherwise."""
        if callable(value):
            def method(*args):
                return value(instance, *args)
            return method
        else:
            return value
</pre>
<p>When a method is called, the first parameter <tt class="docutils literal">self</tt> will be bound to the value
of <tt class="docutils literal">instance</tt> by this definition.</p>
</div>
<div class="section" id="classes">
<h3><a class="toc-backref" href="#id36">2.6.2&nbsp;&nbsp;&nbsp;Classes</a></h3>
<p>A class is also an object, both in Python's object system and the system we are
implementing here.  For simplicity, we say that classes do not themselves have a
class.  (In Python, classes do have classes; almost all classes share the same
class, called <tt class="docutils literal">type</tt>.) A class can respond to <tt class="docutils literal">get</tt> and <tt class="docutils literal">set</tt> messages, as
well as the <tt class="docutils literal">new</tt> message:</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_class(attributes, base_class=None):
        """Return a new class, which is a dispatch dictionary."""
        def get_value(name):
            if name in attributes:
                return attributes[name]
            elif base_class is not None:
                return base_class['get'](name)
        def set_value(name, value):
            attributes[name] = value
        def new(*args):
            return init_instance(cls, *args)
        cls = {'get': get_value, 'set': set_value, 'new': new}
        return cls
</pre>
<p>Unlike an instance, the <tt class="docutils literal">get</tt> function for classes does not query its class
when an attribute is not found, but instead queries its <tt class="docutils literal">base_class</tt>.  No
method binding is required for classes.</p>
<p><strong>Initialization.</strong> The <tt class="docutils literal">new</tt> function in <tt class="docutils literal">make_class</tt> calls
<tt class="docutils literal">init_instance</tt>, which first makes a new instance, then invokes a method
called <tt class="docutils literal">__init__</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def init_instance(cls, *args):
        """Return a new object with type cls, initialized with args."""
        instance = make_instance(cls)
        init = cls['get']('__init__')
        if init:
            init(instance, *args)
        return instance
</pre>
<p>This final function completes our object system.  We now have instances, which
<tt class="docutils literal">set</tt> locally but fall back to their classes on <tt class="docutils literal">get</tt>.  After an instance
looks up a name in its class, it binds itself to function values to create
methods.  Finally, classes can create <tt class="docutils literal">new</tt> instances, and they apply their
<tt class="docutils literal">__init__</tt> constructor function immediately after instance creation.</p>
<p>In this object system, the only function that should be called by the user is
<tt class="docutils literal">create_class</tt>.  All other functionality is enabled through message passing.
Similarly, Python's object system is invoked via the <tt class="docutils literal">class</tt> statement, and
all of its other functionality is enabled through dot expressions and calls to
classes.</p>
</div>
<div class="section" id="using-implemented-objects">
<h3><a class="toc-backref" href="#id37">2.6.3&nbsp;&nbsp;&nbsp;Using Implemented Objects</a></h3>
<p>We now return to use the bank account example from the previous section.  Using
our implemented object system, we will create an <tt class="docutils literal">Account</tt> class, a
<tt class="docutils literal">CheckingAccount</tt> subclass, and an instance of each.</p>
<p>The <tt class="docutils literal">Account</tt> class is created through a <tt class="docutils literal">create_account_class</tt> function,
which has structure similar to a <tt class="docutils literal">class</tt> statement in Python, but concludes
with a call to <tt class="docutils literal">make_class</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_account_class():
        """Return the Account class, which has deposit and withdraw methods."""
        def __init__(self, account_holder):
            self['set']('holder', account_holder)
            self['set']('balance', 0)
        def deposit(self, amount):
            """Increase the account balance by amount and return the new balance."""
            new_balance = self['get']('balance') + amount
            self['set']('balance', new_balance)
            return self['get']('balance')
        def withdraw(self, amount):
            """Decrease the account balance by amount and return the new balance."""
            balance = self['get']('balance')
            if amount &gt; balance:
                return 'Insufficient funds'
            self['set']('balance', balance - amount)
            return self['get']('balance')
        return make_class({'__init__': __init__,
                           'deposit':  deposit,
                           'withdraw': withdraw,
                           'interest': 0.02})
</pre>
<p>In this function, the names of attributes are set at the end.  Unlike Python
<tt class="docutils literal">class</tt> statements, which enforce consistency between intrinsic function names
and attribute names, here we must specify the correspondence between attribute
names and values manually.</p>
<p>The <tt class="docutils literal">Account</tt> class is finally instantiated via assignment.</p>
<pre class="doctest-block">&gt;&gt;&gt; Account = make_account_class()
</pre>
<p>Then, an account instance is created via the <tt class="docutils literal">new</tt> message, which requires a
name to go with the newly created account.</p>
<pre class="doctest-block">&gt;&gt;&gt; jim_acct = Account['new']('Jim')
</pre>
<p>Then, <tt class="docutils literal">get</tt> messages passed to <tt class="docutils literal">jim_acct</tt> retrieve properties and methods.
Methods can be called to update the balance of the account.</p>
<pre class="doctest-block">&gt;&gt;&gt; jim_acct['get']('holder')
'Jim'
&gt;&gt;&gt; jim_acct['get']('interest')
0.02
&gt;&gt;&gt; jim_acct['get']('deposit')(20)
20
&gt;&gt;&gt; jim_acct['get']('withdraw')(5)
15
</pre>
<p>As with the Python object system, setting an attribute of an instance does not
change the corresponding attribute of its class.</p>
<pre class="doctest-block">&gt;&gt;&gt; jim_acct['set']('interest', 0.04)
&gt;&gt;&gt; Account['get']('interest')
0.02
</pre>
<p><strong>Inheritance.</strong> We can create a subclass <tt class="docutils literal">CheckingAccount</tt> by overloading a
subset of the class attributes.  In this case, we change the <tt class="docutils literal">withdraw</tt> method
to impose a fee, and we reduce the interest rate.</p>
<pre class="doctest-block">&gt;&gt;&gt; def make_checking_account_class():
        """Return the CheckingAccount class, which imposes a $1 withdrawal fee."""
        def withdraw(self, amount):
            return Account['get']('withdraw')(self, amount + 1)
        return make_class({'withdraw': withdraw, 'interest': 0.01}, Account)
</pre>
<p>In this implementation, we call the <tt class="docutils literal">withdraw</tt> function of the base class
<tt class="docutils literal">Account</tt> from the <tt class="docutils literal">withdraw</tt> function of the subclass, as we would in
Python's built-in object system.  We can create the subclass itself and an
instance, as before.</p>
<pre class="doctest-block">&gt;&gt;&gt; CheckingAccount = make_checking_account_class()
&gt;&gt;&gt; jack_acct = CheckingAccount['new']('Jack')
</pre>
<p>Deposits behave identically, as does the constructor function.  withdrawals
impose the $1 fee from the specialized <tt class="docutils literal">withdraw</tt> method, and <tt class="docutils literal">interest</tt> has
the new lower value from <tt class="docutils literal">CheckingAccount</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; jack_acct['get']('interest')
0.01
&gt;&gt;&gt; jack_acct['get']('deposit')(20)
20
&gt;&gt;&gt; jack_acct['get']('withdraw')(5)
14
</pre>
<p>Our object system built upon dictionaries is quite similar in implementation
to the built-in object system in Python.  In Python, an instance of any
user-defined class has a special attribute <tt class="docutils literal">__dict__</tt> that stores the local
instance attributes for that object in a dictionary, much like our
<tt class="docutils literal">attributes</tt> dictionary.  Python differs because it distinguishes certain
special methods that interact with built-in functions to ensure that those
functions behave correctly for arguments of many different types.  Functions
that operate on different types are the subject of the next section.</p>
</div>
</div>
<div class="section" id="generic-operations">
<h2><a class="toc-backref" href="#id38">2.7&nbsp;&nbsp;&nbsp;Generic Operations</a></h2>
<p>In this chapter, we introduced compound data values, along with the technique of
data abstraction using constructors and selectors.   Using message passing, we
endowed our abstract data types with behavior directly.  Using the object
metaphor, we bundled together the representation of data and the methods used to
manipulate that data to modularize data-driven programs with local state.</p>
<p>However, we have yet to show that our object system allows us to combine
together different types of objects flexibly in a large program. Message passing
via dot expressions is only one way of building combined expressions with
multiple objects.  In this section, we explore alternate methods for combining
and manipulating objects of different types.</p>
<div class="section" id="string-conversion">
<h3><a class="toc-backref" href="#id39">2.7.1&nbsp;&nbsp;&nbsp;String Conversion</a></h3>
<p>We stated in the beginning of this chapter that an object value should behave
like the kind of data it is meant to represent, including producing a string
representation of itself.  String representations of data values are especially
important in an interactive language like Python, where the <tt class="docutils literal"><span class="pre">read-eval-print</span></tt>
loop requires every value to have some sort of string representation.</p>
<p>String values provide a fundamental medium for communicating information among
humans. Sequences of characters can be rendered on a screen, printed to paper,
read aloud, converted to braille, or broadcast as Morse code.  Strings are also
fundamental to programming because they can represent Python expressions.  For
an object, we may want to generate a string that, when interpreted as a Python
expression, evaluates to an equivalent object.</p>
<p>Python stipulates that all objects should produce two different string
representations: one that is human-interpretable text and one that is a
Python-interpretable expression.  The constructor function for strings, <tt class="docutils literal">str</tt>,
returns a human-readable string. Where possible, the <tt class="docutils literal">repr</tt> function returns a
Python expression that evaluates to an equal object. The docstring for <em>repr</em>
explains this property:</p>
<pre class="literal-block">repr(object) -&gt; string

Return the canonical string representation of the object.
For most object types, eval(repr(object)) == object.
</pre>
<p>The result of calling <tt class="docutils literal">repr</tt> on the value of an expression is what Python
prints in an interactive session.</p>
<pre class="doctest-block">&gt;&gt;&gt; 12e12
12000000000000.0
&gt;&gt;&gt; print(repr(12e12))
12000000000000.0
</pre>
<p>In cases where no representation exists that evaluates to the original value,
Python produces a proxy.</p>
<pre class="doctest-block">&gt;&gt;&gt; repr(min)
'&lt;built-in function min&gt;'
</pre>
<p>The <tt class="docutils literal">str</tt> constructor often coincides with <tt class="docutils literal">repr</tt>, but provides a more
interpretable text representation in some cases.  For instance, we see a
difference between <tt class="docutils literal">str</tt> and <tt class="docutils literal">repr</tt> with dates.</p>
<pre class="doctest-block">&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; today = date(2011, 9, 12)
&gt;&gt;&gt; repr(today)
'datetime.date(2011, 9, 12)'
&gt;&gt;&gt; str(today)
'2011-09-12'
</pre>
<p>Defining the <tt class="docutils literal">repr</tt> function presents a new challenge: we would like it to
apply correctly to all data types, even those that did not exist when <tt class="docutils literal">repr</tt>
was implemented.  We would like it to be a <em>polymorphic function</em>, one that can
be applied to many (<em>poly</em>) different forms (<em>morph</em>) of data.</p>
<p>Message passing provides an elegant solution in this case: the <tt class="docutils literal">repr</tt> function
invokes a method called <tt class="docutils literal">__repr__</tt> on its argument.</p>
<pre class="doctest-block">&gt;&gt;&gt; today.__repr__()
'datetime.date(2011, 9, 12)'
</pre>
<p>By implementing this same method in user-defined classes, we can extend the
applicability of <tt class="docutils literal">repr</tt> to any class we create in the future.  This example
highlights another benefit of message passing in general, that it provides a
mechanism for extending the domain of existing functions to new object types.</p>
<p>The <tt class="docutils literal">str</tt> constructor is implemented in a similar manner: it invokes a method
called <tt class="docutils literal">__str__</tt> on its argument.</p>
<pre class="doctest-block">&gt;&gt;&gt; today.__str__()
'2011-09-12'
</pre>
<p>These polymorphic functions are examples of a more general principle: certain
functions should apply to multiple data types.  The message passing approach
exemplified here is only one of a family of techniques for implementing
polymorphic functions.  The remainder of this section explores some
alternatives.</p>
</div>
<div class="section" id="multiple-representations">
<h3><a class="toc-backref" href="#id40">2.7.2&nbsp;&nbsp;&nbsp;Multiple Representations</a></h3>
<p>Data abstraction, using objects or functions, is a powerful tool for managing
complexity.  Abstract data types allow us to construct an abstraction barrier
between the underlying representation of data and the functions or messages used
to manipulate it.  However, in large programs, it may not always make sense to
speak of "the underlying representation" for a data type in a program. For one
thing, there might be more than one useful representation for a data object, and
we might like to design systems that can deal with multiple representations.</p>
<p>To take a simple example, complex numbers may be represented in two almost
equivalent ways: in rectangular form (real and imaginary parts) and in polar
form (magnitude and angle). Sometimes the rectangular form is more appropriate
and sometimes the polar form is more appropriate. Indeed, it is perfectly
plausible to imagine a system in which complex numbers are represented in both
ways, and in which the functions for manipulating complex numbers work with
either representation.</p>
<p>More importantly, large software systems are often designed by many people
working over extended periods of time, subject to requirements that change over
time. In such an environment, it is simply not possible for everyone to agree in
advance on choices of data representation. In addition to the data-abstraction
barriers that isolate representation from use, we need abstraction barriers that
isolate different design choices from each other and permit different choices to
coexist in a single program. Furthermore, since large programs are often created
by combining pre-existing modules that were designed in isolation, we need
conventions that permit programmers to incorporate modules into larger systems
additively, that is, without having to redesign or re-implement these modules.</p>
<p>We begin with the simple complex-number example. We will see how message passing
enables us to design separate rectangular and polar representations for complex
numbers while maintaining the notion of an abstract "complex-number" object. We
will accomplish this by defining arithmetic functions for complex numbers
(<tt class="docutils literal">add_complex</tt>, <tt class="docutils literal">mul_complex</tt>) in terms of generic selectors that access
parts of a complex number independent of how the number is represented. The
resulting complex-number system contains two different kinds of abstraction
barriers. They isolate higher-level operations from lower-level representations.
In addition, there is a vertical barrier that gives us the ability to separately
design alternative representations.</p>
<div class="figure">
<img alt="img/interface.png" src="02_files/interface.png">
</div>
<p>As a side note, we are developing a system that performs arithmetic operations
on complex numbers as a simple but unrealistic example of a program that uses
generic operations.  A <a class="reference external" href="http://docs.python.org/py3k/library/stdtypes.html#typesnumeric">complex number type</a> is actually
built into Python, but for this example we will implement our own.</p>
<p>Like rational numbers, complex numbers are naturally represented as pairs.  The
set of complex numbers can be thought of as a two-dimensional space with two
orthogonal axes, the real axis and the imaginary axis.  From this point of view,
the complex number <tt class="docutils literal">z = x + y * i</tt> (where <tt class="docutils literal">i*i = <span class="pre">-1</span></tt>)  can be thought of as
the point in the plane whose real coordinate is <tt class="docutils literal">x</tt> and whose imaginary
coordinate is <tt class="docutils literal">y</tt>.  Adding complex numbers involves adding their respective
<tt class="docutils literal">x</tt> and <tt class="docutils literal">y</tt> coordinates.</p>
<p>When multiplying complex numbers, it is more natural to think in terms of
representing a complex number in polar form, as a magnitude and an angle.  The
product of two complex numbers is the vector obtained by stretching one complex
number by a factor of the length of the other, and then rotating it through the
angle of the other.</p>
<p>Thus, there are two different representations for complex numbers, which are
appropriate for different operations. Yet, from the viewpoint of someone writing
a program that uses complex numbers, the principle of data abstraction suggests
that all the operations for manipulating complex numbers should be available
regardless of which representation is used by the computer.</p>
<p><strong>Interfaces.</strong> Message passing not only provides a method for coupling behavior
and data, it allows different data types to respond to the same message in
different ways.  A shared message that elicits similar behavior from different
object classes is a powerful method of abstraction.</p>
<p>As we have seen, an abstract data type is defined by constructors, selectors,
and additional behavior conditions.  A closely related concept is an
<em>interface</em>, which is a set of shared messages, along with a specification of
what they mean.  Objects that respond to the special <tt class="docutils literal">__repr__</tt> and
<tt class="docutils literal">__str__</tt> methods all implement a common interface of types that can be
represented as strings.</p>
<p>In the case of complex numbers, the interface needed to implement arithmetic
consists of four messages: <tt class="docutils literal">real</tt>, <tt class="docutils literal">imag</tt>, <tt class="docutils literal">magnitude</tt>, and
<tt class="docutils literal">angle</tt>.  We can implement addition and multiplication in terms of these
messages.</p>
<p>We can have two different abstract data types for complex numbers that differ in
their constructors.</p>
<ul class="simple">
<li><tt class="docutils literal">ComplexRI</tt> constructs a complex number from real and imaginary parts.</li>
<li><tt class="docutils literal">ComplexMA</tt> constructs a complex number from a magnitude and angle.</li>
</ul>
<p>With these messages and constructors, we can implement complex arithmetic.</p>
<pre class="doctest-block">&gt;&gt;&gt; def add_complex(z1, z2):
        return ComplexRI(z1.real + z2.real, z1.imag + z2.imag)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def mul_complex(z1, z2):
        return ComplexMA(z1.magnitude * z2.magnitude, z1.angle + z2.angle)
</pre>
<p>The relationship between the terms "abstract data type" (ADT) and "interface" is
subtle. An ADT includes ways of building complex data types, manipulating them
as units, and selecting for their components.  In an object-oriented system, an
ADT corresponds to a class, although we have seen that an object system is not
needed to implement an ADT.  An interface is a set of messages that have
associated meanings, and which may or may not include selectors. Conceptually,
an ADT describes a full representational abstraction of some kind of thing,
whereas an interface specifies a set of behaviors that may be shared across many
things.</p>
<p><strong>Properties.</strong> We would like to use both types of complex numbers
interchangeably, but it would be wasteful to store redundant information about
each number.  We would like to store either the real-imaginary representation or
the magnitude-angle representation.</p>
<p>Python has a simple feature for computing attributes on the fly from
zero-argument functions.  The <tt class="docutils literal">@property</tt> decorator allows functions to be
called without the standard call expression syntax.  An implementation of
complex numbers in terms of real and imaginary parts illustrates this point.</p>
<pre class="doctest-block">&gt;&gt;&gt; from math import atan2
&gt;&gt;&gt; class ComplexRI(object):
        def __init__(self, real, imag):
            self.real = real
            self.imag = imag
        @property
        def magnitude(self):
            return (self.real ** 2 + self.imag ** 2) ** 0.5
        @property
        def angle(self):
            return atan2(self.imag, self.real)
        def __repr__(self):
            return 'ComplexRI({0}, {1})'.format(self.real, self.imag)
</pre>
<p>A second implementation using magnitude and angle provides the same interface
because it responds to the same set of messages.</p>
<pre class="doctest-block">&gt;&gt;&gt; from math import sin, cos
&gt;&gt;&gt; class ComplexMA(object):
        def __init__(self, magnitude, angle):
            self.magnitude = magnitude
            self.angle = angle
        @property
        def real(self):
            return self.magnitude * cos(self.angle)
        @property
        def imag(self):
            return self.magnitude * sin(self.angle)
        def __repr__(self):
            return 'ComplexMA({0}, {1})'.format(self.magnitude, self.angle)
</pre>
<p>In fact, our implementations of <tt class="docutils literal">add_complex</tt> and <tt class="docutils literal">mul_complex</tt> are now
complete; either class of complex number can be used for either argument in
either complex arithmetic function.  It is worth noting that the object system
does not explicitly connect the two complex types in any way (e.g., through
inheritance).  We have implemented the complex number abstraction by sharing a
common set of messages, an interface, across the two classes.</p>
<pre class="doctest-block">&gt;&gt;&gt; from math import pi
&gt;&gt;&gt; add_complex(ComplexRI(1, 2), ComplexMA(2, pi/2))
ComplexRI(1.0000000000000002, 4.0)
&gt;&gt;&gt; mul_complex(ComplexRI(0, 1), ComplexRI(0, 1))
ComplexMA(1.0, 3.141592653589793)
</pre>
<p>The interface approach to encoding multiple representations has appealing
properties.  The class for each representation can be developed separately; they
must only agree on the names of the attributes they share.  The interface is
also <em>additive</em>.  If another programmer wanted to add a third representation of
complex numbers to the same program, they would only have to create another
class with the same attributes.</p>
<p><strong>Special methods.</strong> The built-in mathematical operators can be extended in much
the same way as <tt class="docutils literal">repr</tt>; there are special method names corresponding to Python
operators for arithmetic, logical, and sequence operations.</p>
<p>To make our code more legible, we would perhaps like to use the <tt class="docutils literal">+</tt> and <tt class="docutils literal">*</tt>
operators directly when adding and multiplying complex numbers. Adding the
following methods to both of our complex number classes will enable these
operators to be used, as well as the <tt class="docutils literal">add</tt> and <tt class="docutils literal">mul</tt> functions in the
<tt class="docutils literal">operator</tt> module:</p>
<pre class="doctest-block">&gt;&gt;&gt; ComplexRI.__add__ = lambda self, other: add_complex(self, other)
&gt;&gt;&gt; ComplexMA.__add__ = lambda self, other: add_complex(self, other)
&gt;&gt;&gt; ComplexRI.__mul__ = lambda self, other: mul_complex(self, other)
&gt;&gt;&gt; ComplexMA.__mul__ = lambda self, other: mul_complex(self, other)
</pre>
<p>Now, we can use infix notation with our user-defined classes.</p>
<pre class="doctest-block">&gt;&gt;&gt; ComplexRI(1, 2) + ComplexMA(2, 0)
ComplexRI(3.0, 2.0)
&gt;&gt;&gt; ComplexRI(0, 1) * ComplexRI(0, 1)
ComplexMA(1.0, 3.141592653589793)
</pre>
<p><strong>Further reading.</strong> To evaluate expressions that contain the <tt class="docutils literal">+</tt> operator,
Python checks for special methods on both the left and right operands of the
expression.  First, Python checks for an <tt class="docutils literal">__add__</tt> method on the value
of the left operand, then checks for an <tt class="docutils literal">__radd__</tt> method on the value
of the right operand.  If either is found, that method is invoked with the value
of the other operand as its argument.</p>
<p>Similar protocols exist for evaluating expressions that contain any kind of
operator in Python, including slice notation and Boolean operators.  The Python
docs list the exhaustive set of <a class="reference external" href="http://docs.python.org/py3k/reference/datamodel.html#special-method-names">method names for operators</a>.
Dive into Python 3 has a chapter on <a class="reference external" href="http://diveintopython3.ep.io/special-method-names.html">special method names</a> that describes many
details of their use in the Python interpreter.</p>
</div>
<div class="section" id="generic-functions">
<h3><a class="toc-backref" href="#id41">2.7.3&nbsp;&nbsp;&nbsp;Generic Functions</a></h3>
<p>Our implementation of complex numbers has made two data types interchangeable as
arguments to the <tt class="docutils literal">add_complex</tt> and <tt class="docutils literal">mul_complex</tt> functions.  Now we will see
how to use this same idea not only to define operations that are generic over
different representations but also to define operations that are generic over
different kinds of arguments that do not share a common interface.</p>
<p>The operations we have defined so far treat the different data types as being
completely independent. Thus, there are separate packages for adding, say, two
rational numbers, or two complex numbers. What we have not yet considered is the
fact that it is meaningful to define operations that cross the type boundaries,
such as the addition of a complex number to a rational number. We have gone to
great pains to introduce barriers between parts of our programs so that they can
be developed and understood separately.</p>
<p>We would like to introduce the cross-type operations in some carefully
controlled way, so that we can support them without seriously violating our
abstraction boundaries.  There is a tension between the outcomes we desire: we
would like to be able to add a complex number to a rational number, and we would
like to do so using a generic <tt class="docutils literal">add</tt> function that does the right thing with
all numeric types.  At the same time, we would like to separate the concerns of
complex numbers and rational numbers whenever possible, in order to maintain a
modular program.</p>
<p>Let us revise our implementation of rational numbers to use Python's built-in
object system.  As before, we will store a rational number as a numerator and
denominator in lowest terms.</p>
<pre class="doctest-block">&gt;&gt;&gt; from fractions import gcd
&gt;&gt;&gt; class Rational(object):
        def __init__(self, numer, denom):
            g = gcd(numer, denom)
            self.numer = numer // g
            self.denom = denom // g
        def __repr__(self):
            return 'Rational({0}, {1})'.format(self.numer, self.denom)
</pre>
<p>Adding and multiplying rational numbers in this new implementation is similar to
before.</p>
<pre class="doctest-block">&gt;&gt;&gt; def add_rational(x, y):
        nx, dx = x.numer, x.denom
        ny, dy = y.numer, y.denom
        return Rational(nx * dy + ny * dx, dx * dy)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def mul_rational(x, y):
        return Rational(x.numer * y.numer, x.denom * y.denom)
</pre>
<p><strong>Type dispatching.</strong> One way to handle cross-type operations is to design a
different function for each possible combination of types for which the
operation is valid. For example, we could extend our complex number
implementation so that it provides a function for adding complex numbers to
rational numbers. We can provide this functionality generically using a
technique called <em>dispatching on type</em>.</p>
<p>The idea of type dispatching is to write functions that first inspect the type
of argument they have received, and then execute code that is appropriate for
the type.  In Python, the type of an object can be inspected with the built-in
<tt class="docutils literal">type</tt> function.</p>
<pre class="doctest-block">&gt;&gt;&gt; def iscomplex(z):
        return type(z) in (ComplexRI, ComplexMA)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def isrational(z):
        return type(z) == Rational
</pre>
<p>In this case, we are relying on the fact that each object knows its type, and we
can look up that type using the Python <tt class="docutils literal">type</tt> function.  Even if the <tt class="docutils literal">type</tt>
function were not available, we could imagine implementing <tt class="docutils literal">iscomplex</tt> and
<tt class="docutils literal">isrational</tt> in terms of a shared class attribute for <tt class="docutils literal">Rational</tt>,
<tt class="docutils literal">ComplexRI</tt>, and <tt class="docutils literal">ComplexMA</tt>.</p>
<p>Now consider the following implementation of <tt class="docutils literal">add</tt>, which explicitly checks
the type of both arguments.  We will not use Python's special methods (i.e.,
<tt class="docutils literal">__add__</tt>) in this example.</p>
<pre class="doctest-block">&gt;&gt;&gt; def add_complex_and_rational(z, r):
            return ComplexRI(z.real + r.numer/r.denom, z.imag)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; def add(z1, z2):
        """Add z1 and z2, which may be complex or rational."""
        if iscomplex(z1) and iscomplex(z2):
            return add_complex(z1, z2)
        elif iscomplex(z1) and isrational(z2):
            return add_complex_and_rational(z1, z2)
        elif isrational(z1) and iscomplex(z2):
            return add_complex_and_rational(z2, z1)
        else:
            return add_rational(z1, z2)
</pre>
<p>This simplistic approach to type dispatching, which uses a large conditional
statement, is not additive.  If another numeric type were included in the
program, we would have to re-implement <tt class="docutils literal">add</tt> with new clauses.</p>
<p>We can create a more flexible implementation of <tt class="docutils literal">add</tt> by implementing type
dispatch through a dictionary.  The first step in extending the flexibility of
<tt class="docutils literal">add</tt> will be to create a tag set for our classes that abstracts away from the
two implementations of complex numbers.</p>
<pre class="doctest-block">&gt;&gt;&gt; def type_tag(x):
        return type_tag.tags[type(x)]
</pre>
<pre class="doctest-block">&gt;&gt;&gt; type_tag.tags = {ComplexRI: 'com', ComplexMA: 'com', Rational: 'rat'}
</pre>
<p>Next, we use these type tags to index a dictionary that stores the different
ways of adding numbers.  The keys of the dictionary are tuples of type tags, and
the values are type-specific addition functions.</p>
<pre class="doctest-block">&gt;&gt;&gt; def add(z1, z2):
        types = (type_tag(z1), type_tag(z2))
        return add.implementations[types](z1, z2)
</pre>
<p>This definition of <tt class="docutils literal">add</tt> does not have any functionality itself; it relies
entirely on a dictionary called <tt class="docutils literal">add.implementations</tt> to implement addition.
We can populate that dictionary as follows.</p>
<pre class="doctest-block">&gt;&gt;&gt; add.implementations = {}
&gt;&gt;&gt; add.implementations[('com', 'com')] = add_complex
&gt;&gt;&gt; add.implementations[('com', 'rat')] = add_complex_and_rational
&gt;&gt;&gt; add.implementations[('rat', 'com')] = lambda x, y: add_complex_and_rational(y, x)
&gt;&gt;&gt; add.implementations[('rat', 'rat')] = add_rational
</pre>
<p>This dictionary-based approach to dispatching is additive, because
<tt class="docutils literal">add.implementations</tt> and <tt class="docutils literal">type_tag.tags</tt> can always be extended.  Any new
numeric type can "install" itself into the existing system by adding new entries
to these dictionaries.</p>
<p>While we have introduced some complexity to the system, we now have a generic,
extensible <tt class="docutils literal">add</tt> function that handles mixed types.</p>
<pre class="doctest-block">&gt;&gt;&gt; add(ComplexRI(1.5, 0), Rational(3, 2))
ComplexRI(3.0, 0)
&gt;&gt;&gt; add(Rational(5, 3), Rational(1, 2))
Rational(13, 6)
</pre>
<p><strong>Data-directed programming.</strong> Our dictionary-based implementation of <tt class="docutils literal">add</tt>
is not addition-specific at all; it does not contain any direct addition logic.
It only implements addition because we happen to have populated its
<tt class="docutils literal">implementations</tt> dictionary with functions that perform addition.</p>
<p>A more general version of generic arithmetic would apply arbitrary operators to
arbitrary types and use a dictionary to store implementations of various
combinations.  This fully generic approach to implementing methods is called
<em>data-directed programming</em>.  In our case, we can implement both generic
addition and multiplication without redundant logic.</p>
<pre class="doctest-block">&gt;&gt;&gt; def apply(operator_name, x, y):
        tags = (type_tag(x), type_tag(y))
        key = (operator_name, tags)
        return apply.implementations[key](x, y)
</pre>
<p>In this generic <tt class="docutils literal">apply</tt> function, a key is constructed from the operator name
(e.g., <tt class="docutils literal">'add'</tt>) and a tuple of type tags for the arguments. Implementations
are also populated using these tags.  We enable support for multiplication on
complex and rational numbers below.</p>
<pre class="doctest-block">&gt;&gt;&gt; def mul_complex_and_rational(z, r):
        return ComplexMA(z.magnitude * r.numer / r.denom, z.angle)
</pre>
<pre class="doctest-block">&gt;&gt;&gt; mul_rational_and_complex = lambda r, z: mul_complex_and_rational(z, r)
&gt;&gt;&gt; apply.implementations = {('mul', ('com', 'com')): mul_complex,
                             ('mul', ('com', 'rat')): mul_complex_and_rational,
                             ('mul', ('rat', 'com')): mul_rational_and_complex,
                             ('mul', ('rat', 'rat')): mul_rational}
</pre>
<p>We can also include the addition implementations from <tt class="docutils literal">add</tt> to <tt class="docutils literal">apply</tt>,
using the dictionary <tt class="docutils literal">update</tt> method.</p>
<pre class="doctest-block">&gt;&gt;&gt; adders = add.implementations.items()
&gt;&gt;&gt; apply.implementations.update({('add', tags):fn for (tags, fn) in adders})
</pre>
<p>Now that apply supports 8 different implementations in a single table, we can
use it to manipulate rational and complex numbers quite generically.</p>
<pre class="doctest-block">&gt;&gt;&gt; apply('add', ComplexRI(1.5, 0), Rational(3, 2))
ComplexRI(3.0, 0)
&gt;&gt;&gt; apply('mul', Rational(1, 2), ComplexMA(10, 1))
ComplexMA(5.0, 1)
</pre>
<p>This data-directed approach does manage the complexity of cross-type operators,
but it is cumbersome. With such a system, the cost of introducing a new type is
not just writing methods for that type, but also the construction and
installation of the functions that implement the cross-type operations. This
burden can easily require much more code than is needed to define the operations
on the type itself.</p>
<p>While the techniques of dispatching on type and data-directed programming do
create additive implementations of generic functions, they do not effectively
separate implementation concerns; implementors of the individual numeric types
need to take account of other types when writing cross-type operations.
Combining rational numbers and complex numbers isn't strictly the domain of
either type.  Formulating coherent policies on the division of responsibility
among types can be an overwhelming task in designing systems with many types and
cross-type operations.</p>
<p><strong>Coercion.</strong> In the general situation of completely unrelated operations acting
on completely unrelated types, implementing explicit cross-type operations,
cumbersome though it may be, is the best that one can hope for. Fortunately, we
can sometimes do better by taking advantage of additional structure that may be
latent in our type system. Often the different data types are not completely
independent, and there may be ways by which objects of one type may be viewed as
being of another type. This process is called <em>coercion</em>. For example, if
we are asked to arithmetically combine a rational number with a complex number,
we can view the rational number as a complex number whose imaginary part is
zero. By doing so, we transform the problem to that of combining two complex
numbers, which can be handled in the ordinary way by <tt class="docutils literal">add_complex</tt> and
<tt class="docutils literal">mul_complex</tt>.</p>
<p>In general, we can implement this idea by designing coercion functions that
transform an object of one type into an equivalent object of another type. Here
is a typical coercion function, which transforms a rational number to a complex
number with zero imaginary part:</p>
<pre class="doctest-block">&gt;&gt;&gt; def rational_to_complex(x):
        return ComplexRI(x.numer/x.denom, 0)
</pre>
<p>Now, we can define a dictionary of coercion functions.  This dictionary could be
extended as more numeric types are introduced.</p>
<pre class="doctest-block">&gt;&gt;&gt; coercions = {('rat', 'com'): rational_to_complex}
</pre>
<p>It is not generally possible to coerce an arbitrary data object of each type
into all other types. For example, there is no way to coerce an arbitrary
complex number to a rational number, so there will be no such conversion
implementation in the <tt class="docutils literal">coercions</tt> dictionary.</p>
<p>Using the <tt class="docutils literal">coercions</tt> dictionary, we can write a function called
<tt class="docutils literal">coerce_apply</tt>, which attempts to coerce arguments into values of the same
type, and only then applies an operator. The implementations dictionary of
<tt class="docutils literal">coerce_apply</tt> does not include any cross-type operator implementations.</p>
<pre class="doctest-block">&gt;&gt;&gt; def coerce_apply(operator_name, x, y):
        tx, ty = type_tag(x), type_tag(y)
        if tx != ty:
            if (tx, ty) in coercions:
                tx, x = ty, coercions[(tx, ty)](x)
            elif (ty, tx) in coercions:
                ty, y = tx, coercions[(ty, tx)](y)
            else:
                return 'No coercion possible.'
        key = (operator_name, tx)
        return coerce_apply.implementations[key](x, y)
</pre>
<p>The <tt class="docutils literal">implementations</tt> of <tt class="docutils literal">coerce_apply</tt> require only one type tag, because
they assume that both values share the same type tag.  Hence, we require only
four implementations to support generic arithmetic over complex and rational
numbers.</p>
<pre class="doctest-block">&gt;&gt;&gt; coerce_apply.implementations = {('mul', 'com'): mul_complex,
                                    ('mul', 'rat'): mul_rational,
                                    ('add', 'com'): add_complex,
                                    ('add', 'rat'): add_rational}
</pre>
<p>With these implementations in place, <tt class="docutils literal">coerce_apply</tt> can replace <tt class="docutils literal">apply</tt>.</p>
<pre class="doctest-block">&gt;&gt;&gt; coerce_apply('add', ComplexRI(1.5, 0), Rational(3, 2))
ComplexRI(3.0, 0)
&gt;&gt;&gt; coerce_apply('mul', Rational(1, 2), ComplexMA(10, 1))
ComplexMA(5.0, 1.0)
</pre>
<p>This coercion scheme has some advantages over the method of defining explicit
cross-type operations. Although we still need to write coercion functions to
relate the types, we need to write only one function for each pair of types
rather than a different functions for each collection of types and each generic
operation. What we are counting on here is the fact that the appropriate
transformation between types depends only on the types themselves, not on the
particular operation to be applied.</p>
<p>Further advantages come from extending coercion.  Some more sophisticated
coercion schemes do not just try to coerce one type into another, but instead
may try to coerce two different types each into a third common type.  Consider a
rhombus and a rectangle: neither is a special case of the other, but both can be
viewed as quadrilaterals. Another extension to coercion is iterative coercion,
in which one data type is coerced into another via intermediate types.  Consider
that an integer can be converted into a real number by first converting it into
a rational number, then converting that rational number into a real number.
Chaining coercion in this way can reduce the total number of coercion functions
that are required by a program.</p>
<p>Despite its advantages, coercion does have potential drawbacks.  For one,
coercion functions can lose information when they are applied.  In our example,
rational numbers are exact representations, but become approximations when they
are converted to complex numbers.</p>
<p>Some programming languages have automatic coercion systems built in.  In fact,
early versions of Python had a <tt class="docutils literal">__coerce__</tt> special method on objects.  In the
end, the complexity of the built-in coercion system did not justify its use, and
so it was removed.  Instead, particular operators apply coercion to their
arguments as needed.  Operators are implemented as method calls on user defined
types using special methods like <tt class="docutils literal">__add__</tt> and <tt class="docutils literal">__mul__</tt>.  It is left up to
you, the user, to decide whether to employ type dispatching, data-directed
programming, message passing, or coercion in order to implement generic
functions in your programs.</p>
</div>
</div>
</div>


</body></html>
